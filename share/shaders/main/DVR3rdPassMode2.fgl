#version 410 core

in vec4 positionClip;   // vertex position in the clip space
in vec4 positionModel;  // vertex position in the clip space
flat in ivec4 provokingVertexIdx;
layout(location = 0) out vec4 color;

uniform sampler2D       backFaceTexture;
uniform sampler2D       frontFaceTexture;
uniform sampler3D       volumeTexture;
uniform usampler3D      missingValueMaskTexture; // !!unsigned integer!!
uniform sampler1D       colorMapTexture;
uniform samplerBuffer   xyCoordsTexture;
uniform samplerBuffer   zCoordsTexture;

uniform vec2 valueRange;        // min and max values of this variable
uniform vec2 colorMapRange;     // min and max values on this color map
uniform vec3 boxMin;            // min coordinates of the bounding box of this volume
uniform vec3 boxMax;            // max coordinates of the bounding box of this volume
uniform ivec3 volumeDims;       // number of vertices in this volume
uniform vec4 clipPlanes[6];     // clipping planes in **un-normalized** model coordinates

uniform float stepSize1D;       // ray casting step size
uniform bool  lighting;         // apply lighting or not
uniform bool  hasMissingValue;  // has missing values or not
uniform float lightingCoeffs[4]; // lighting parameters

uniform mat4 transposedInverseMV;   // transpose(inverse(ModelView))
uniform mat4 ModelView;

//
// Derive helper variables
//
const float EPSILON  = 5e-6;
float ambientCoeff   = lightingCoeffs[0];
float diffuseCoeff   = lightingCoeffs[1];
float specularCoeff  = lightingCoeffs[2];
float specularExp    = lightingCoeffs[3];
vec3  volumeDimsf    = vec3( float(volumeDims.x), float(volumeDims.y), float(volumeDims.z) );
vec3  volumeStepf    = 1.0 / volumeDimsf;

//
// Input:  normalized value w.r.t. valueRange.
// Output: normalized value w.r.t. colorMapRange.
//
float TranslateValue( const in float value )
{
    float   orig = value * (valueRange.y - valueRange.x) + valueRange.x;
    return (orig - colorMapRange.x) / (colorMapRange.y - colorMapRange.x);
}

//
// Input:  logical index of a vertex
// Output: normalized user coordinate of this vertex
//
vec3 GetCoordinates( const in ivec3 index )
{
    int xyOffset = index.y *  volumeDims.x + index.x;
    int zOffset  = index.z * (volumeDims.x * volumeDims.y) + xyOffset;
    vec4 xyC     = texelFetch( xyCoordsTexture, xyOffset );
    vec4 zC      = texelFetch( zCoordsTexture,  zOffset );
    return vec3( xyC.xy, zC.x );
}

//
// Input:  Location to be evaluated in texture coordinates.
// Output: If this location should be skipped.
// Note:   It is skipped in two cases: 1) it represents a missing value
//                                     2) it is outside of clipping planes
//
bool ShouldSkip( const in vec3 tc )
{
    if( hasMissingValue && (texture(missingValueMaskTexture, tc).r != 0u) )
        return true;

    vec4 positionModel  = vec4( (boxMin + tc * (boxMax - boxMin)), 1.0 );
    for( int i = 0; i < 6; i++ )
    {
        if( dot(positionModel, clipPlanes[i]) < 0.0 )
            return true;
    }

    return false;
}

//
// Input:  Location to be evaluated in texture coordinates
// Output: Gradient at that location
//
vec3 CalculateGradient( const in vec3 tc)
{
    vec3 h0 = vec3(-0.5 ) / volumeDimsf;
    vec3 h1 = vec3( 0.5 ) / volumeDimsf;
    vec3 h  = vec3( 1.0 );

    if ((tc.x + h0.x) < 0.0) {
        h0.x = 0.0;
        h.x = 0.5;
    }
    if ((tc.x + h1.x) > 1.0) {
        h1.x = 0.0;
        h.x = 0.5;
    }
    if ((tc.y + h0.y) < 0.0) {
        h0.y = 0.0;
        h.y = 0.5;
    }
    if ((tc.y + h1.y) > 1.0) {
        h1.y = 0.0;
        h.y = 0.5;
    }
    if ((tc.z + h0.z) < 0.0) {
        h0.z = 0.0;
        h.z = 0.5;
    }
    if ((tc.z + h1.z) > 1.0) {
        h1.z = 0.0;
        h.z = 0.5;
    }

    vec3 a0, a1;
    a0.x = texture( volumeTexture, tc + vec3(h0.x,0.0,0.0) ).r;
    a1.x = texture( volumeTexture, tc + vec3(h1.x,0.0,0.0) ).r;
    a0.y = texture( volumeTexture, tc + vec3(0.0,h0.y,0.0) ).r;
    a1.y = texture( volumeTexture, tc + vec3(0.0,h1.y,0.0) ).r;
    a0.z = texture( volumeTexture, tc + vec3(0.0,0.0,h0.z) ).r;
    a1.z = texture( volumeTexture, tc + vec3(0.0,0.0,h1.z) ).r;

    return (a1-a0 / h);
}

// reference implementation: 
// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection
bool RayTriangleIntersect( const in vec3 orig, const in vec3 dir,
                           const in vec3 v0,   const in vec3 v1,  const in vec3 v2,
                           out float t,        out float u,       out float v ) 
{
    vec3 v0v1 = v1 - v0;
    vec3 v0v2 = v2 - v0;
    vec3 pvec = cross( dir, v0v2 );
    float det = dot(  v0v1, pvec );

    const float zero = 1e-8;
    if( abs(det) < zero ) // ray and triangle are parallel
    {
        t = -1.0;   u = -1.0;   v = -1.0;
        return false;
    }

    float invDet = 1.0 / det;
    vec3  tvec   = orig - v0;
    u            = dot( tvec, pvec ) * invDet;  // if u == 0, ray hits edge v0v2
    vec3 qvec    = cross( tvec, v0v1 );
    v            = dot( dir, qvec ) * invDet;   // if v == 0, ray hits edge v0v1
    t            = dot( v0v2, qvec ) * invDet;

    if( u < 0.0 || v < 0.0 || u + v > 1.0 )
        return false;
    else
        return true;
}


int   FindNextCell( const in ivec4 step1CellIdx,    const in vec3 startTexture,
                    const in  vec3 rayDirTexture,
                    out      ivec4 step2CellIdx,    out float t )
{
    //          Y
    //        4 __________________5
    //         /|               /|
    //        / |              / |
    //       /  |             /  |
    //     7/___|___________6/   |
    //      |   |           |    |
    //      |   |           |    |
    //      |   |___________|____|  X
    //      |   /0          |   /1
    //      |  /            |  /
    //      | /             | /
    //     3|/______________|/    
    //                     2
    //     Z
    ivec3 V0 = step1CellIdx.xyz;

    ivec3 cubeVertIdx[8]; 
    cubeVertIdx[0] = V0;
    cubeVertIdx[1] = ivec3(V0.x + 1, V0.y    , V0.z     );
    cubeVertIdx[2] = ivec3(V0.x + 1, V0.y    , V0.z + 1 );
    cubeVertIdx[3] = ivec3(V0.x    , V0.y    , V0.z + 1 );
    cubeVertIdx[4] = ivec3(V0.x    , V0.y + 1, V0.z     );
    cubeVertIdx[5] = ivec3(V0.x + 1, V0.y + 1, V0.z     );
    cubeVertIdx[6] = ivec3(V0.x + 1, V0.y + 1, V0.z + 1 );
    cubeVertIdx[7] = ivec3(V0.x    , V0.y + 1, V0.z + 1 );

    vec3 cubeVertCoords[8];
    for( int i = 0; i < 8; i++ )
        cubeVertCoords[i] = GetCoordinates( cubeVertIdx[i] );

    ivec3 triangles[12];
    triangles[0]  =  ivec3( 7, 3, 6 );  // front face,  w == 0
    triangles[1]  =  ivec3( 2, 3, 6 );
    triangles[2]  =  ivec3( 0, 4, 1 );  // back face,   w == 1
    triangles[3]  =  ivec3( 5, 4, 1 );
    triangles[4]  =  ivec3( 4, 7, 5 );  // top face,    w == 2
    triangles[5]  =  ivec3( 6, 7, 5 );
    triangles[6]  =  ivec3( 3, 0, 2 );  // bottom face, w == 3
    triangles[7]  =  ivec3( 1, 0, 2 );
    triangles[8]  =  ivec3( 5, 1, 6 );  // right face,  w == 4
    triangles[9]  =  ivec3( 2, 1, 6 );
    triangles[10] =  ivec3( 4, 0, 7 );  // left face,   w == 5
    triangles[11] =  ivec3( 3, 0, 7 );

    // Test intersection with 12 triangles
    bool  intersect[12];
    float tArr[12],    uArr[12],   vArr[12];
    for( int i = 0; i < 12; i++ )
    {
        intersect[i] = RayTriangleIntersect( startTexture,   rayDirTexture,
                                             cubeVertCoords[ triangles[i][0] ],
                                             cubeVertCoords[ triangles[i][1] ],
                                             cubeVertCoords[ triangles[i][2] ],
                                             tArr[i],  uArr[i],  vArr[i]     );
    }

    // How many triangles does this ray hit? 
    int counter = 0;
    for( int i = 0; i < 12; i++ )
    {
        if( intersect[i] )
            counter++;
    }

    // Bring back missing hits
    if( counter < 2 )
    {
        float zero = 4e-4;
        for( int i = 0; i < 12; i++ )
        {
            if( abs(uArr[i]) < zero || abs(vArr[i]) < zero || 
                abs(uArr[i] + vArr[i] - 1.0) < zero )
            intersect[i] = true;
        }
    }

    // Re-count the number of intersections after all the treatments
    counter = 0;
    for( int i = 0; i < 12; i++ )
    {
        if( intersect[i] )
            counter++;
    }

    // Eliminate invalid hits
    if( counter > 2 )
    {
        // If a ray hits both front and back faces, then mark any other intersections false
        if( (intersect[0] || intersect[1]) && (intersect[2] || intersect[3]) )
        {
            for( int i = 4; i < 12; i++ )
                intersect[i] = false;
        }
        // If a ray hits both top and bottom faces, then mark any other intersections false
        if( (intersect[4] || intersect[5]) && (intersect[6] || intersect[7]) )
        {
            for( int i = 0; i < 4; i++ )
                intersect[i] = false;
            for( int i = 8; i < 12; i++ )
                intersect[i] = false;
        }
        // If a ray hits both left and right faces, then mark any other intersections false
        if( (intersect[8] || intersect[9]) && (intersect[10] || intersect[11]) )
        {
            for( int i = 0; i < 8; i++ )
                intersect[i] = false;
        }

        // If a ray hits both triangles of the same face, remove one of them
        for( int i = 0; i < 6; i++ )
        {
            if( intersect[ i*2 ] && intersect[ i*2+1 ] )
                intersect[ i*2 ] = false;
        }
    }

    // Re-count the number of intersections after all the treatments
    counter = 0;
    for( int i = 0; i < 12; i++ )
    {
        if( intersect[i] )
            counter++;
    }

    // Another round of hit elimination, where the ray entry point is on an edge.
    if( counter > 2 )
    {
        const float zero = 3e-7;
        int i = 0;
        if( intersect[i] && (i/2 == step1CellIdx.w) )
        {
            if( abs( vArr[i] ) < zero )     // hitting edge 7-3
                intersect[11]  = false;
            if( abs( uArr[i] ) < zero )     // hitting edge 7-6
                intersect[5]   = false;
        }
        i = 1;
        if( intersect[i] && (i/2 == step1CellIdx.w) )
        {
            if( abs( vArr[i] ) < zero )     // hitting edge 2-3
                intersect[6]   = false;
            if( abs( uArr[i] ) < zero )     // hitting edge 2-6
                intersect[9]   = false;
        }
        i = 2;
        if( intersect[i] && (i/2 == step1CellIdx.w) )
        {
            if( abs( vArr[i] ) < zero )     // hitting edge 0-4
                intersect[10]  = false;
            if( abs( uArr[i] ) < zero )     // hitting edge 0-1
                intersect[7]   = false;
        }
        i = 3;
        if( intersect[i] && (i/2 == step1CellIdx.w) )
        {
            if( abs( vArr[i] ) < zero )     // hitting edge 5-4
                intersect[4]   = false;
            if( abs( uArr[i] ) < zero )     // hitting edge 5-1
                intersect[8]   = false;
        }
        i = 4;
        if( intersect[i] && (i/2 == step1CellIdx.w) )
        {
            if( abs( vArr[i] ) < zero )     // hitting edge 4-7
                intersect[10]  = false;
            if( abs( uArr[i] ) < zero )     // hitting edge 4-5
                intersect[3]   = false;
        }
        i = 5;
        if( intersect[i] && (i/2 == step1CellIdx.w) )
        {
            if( abs( vArr[i] ) < zero )     // hitting edge 6-7
                intersect[0]   = false;
            if( abs( uArr[i] ) < zero )     // hitting edge 6-5
                intersect[8]   = false;
        }
        i = 6;
        if( intersect[i] && (i/2 == step1CellIdx.w) )
        {
            if( abs( vArr[i] ) < zero )     // hitting edge 3-0
                intersect[11]  = false;
            if( abs( uArr[i] ) < zero )     // hitting edge 3-2
                intersect[1]   = false;
        }
        i = 7;
        if( intersect[i] && (i/2 == step1CellIdx.w) )
        {
            if( abs( vArr[i] ) < zero )     // hitting edge 1-0
                intersect[2]   = false;
            if( abs( uArr[i] ) < zero )     // hitting edge 1-2
                intersect[9]   = false;
        }
        i = 8;
        if( intersect[i] && (i/2 == step1CellIdx.w) )
        {
            if( abs( vArr[i] ) < zero )     // hitting edge 5-1
                intersect[3]   = false;
            if( abs( uArr[i] ) < zero )     // hitting edge 5-6
                intersect[5]   = false;
        }
        i = 9;
        if( intersect[i] && (i/2 == step1CellIdx.w) )
        {
            if( abs( vArr[i] ) < zero )     // hitting edge 2-1
                intersect[7]   = false;
            if( abs( uArr[i] ) < zero )     // hitting edge 2-6
                intersect[1]   = false;
        }
        i = 10;
        if( intersect[i] && (i/2 == step1CellIdx.w) )
        {
            if( abs( vArr[i] ) < zero )     // hitting edge 4-0
                intersect[2]   = false;
            if( abs( uArr[i] ) < zero )     // hitting edge 4-7
                intersect[4]   = false;
        }
        i = 11;
        if( intersect[i] && (i/2 == step1CellIdx.w) )
        {
            if( abs( vArr[i] ) < zero )     // hitting edge 3-0
                intersect[6]   = false;
            if( abs( uArr[i] ) < zero )     // hitting edge 3-7
                intersect[0]   = false;
        }
    }

    // Re-count the number of intersections after all the treatments
    counter = 0;
    for( int i = 0; i < 12; i++ )
    {
        if( intersect[i] )
            counter++;
    }


#if 0
    if( counter == 2 )      // one entry, and one exit
    {
        int i;
        for( i = 0; i < 12; i++ )   // find the exit face
        {
            if( intersect[i] && i / 2 != step1CellIdx.w )
                break;
        }
        
        t = tArr[i];

        if( i / 2 == 0 )        // exits the front face of current cell
        {                       // enters the back face of the next cell
            step2CellIdx = ivec4( cubeVertIdx[3], 1 );
        }
        else if( i / 2 == 1 )   // exits the back face of current cell
        {                       // enters the front face of the next cell
            step2CellIdx = ivec4( V0.x, V0.y, V0.z - 1, 0 );
        }
        else if( i / 2 == 4 )   // exits the right face of current cell
        {                       // enters the left face of the next cell
            step2CellIdx = ivec4( cubeVertIdx[1], 5 );
        }
        else if( i / 2 == 5 )   // exits the left face of current cell
        {                       // enters the right face of the next cell
            step2CellIdx = ivec4( V0.x - 1, V0.y, V0.z, 4 );
        }
        else if( i / 2 == 2 )   // exits the top face of current cell
        {                       // enters the bottom face of the next cell
            step2CellIdx = ivec4(  cubeVertIdx[4], 3 );
        }
        else //( i / 2 == 3)    // exits the bottom face of current cell
        {                       // enters the top face of the next cell
            step2CellIdx = ivec4( V0.x, V0.y - 1, V0.z, 2 );
        }
    }
    else if( counter == 1 ) // ray hitting an edge
    {
        int i;
        for( i = 0; i < 12; i++ )   // Find the only intersection face
        {
            if( intersect[i] )
                break;
        }

    }
    else if( counter == 0 ) // ray missing this cell ??
    {

    }
    else                    // ray hitting more than 2 triangles ??
    {

    }
#endif

    return counter;
}

bool CellOutsideBound( const in ivec3 cellIdx )
{
    if( cellIdx.x < 0 || cellIdx.x > volumeDims.x - 2 || 
        cellIdx.y < 0 || cellIdx.y > volumeDims.y - 2 ||
        cellIdx.z < 0 || cellIdx.z > volumeDims.z - 2   )
        return true;
    else
        return false;
}

void main(void)
{
    vec3  lightDirEye   = vec3(0.0, 0.0, 1.0); 

    // Get UV coordinates of this frament
    if( abs(positionClip.w) < EPSILON )
        discard;
    vec2 positionUV     = ((positionClip.xy / positionClip.w) + 1.0) / 2.0;

    vec3 stopTexture    = texture( backFaceTexture,  positionUV ).xyz;
    vec3 startTexture   = texture( frontFaceTexture, positionUV ).xyz;
    vec3 rayDirTexture  = stopTexture - startTexture;
    float rayDirLength  = length( rayDirTexture );
    if( rayDirLength < EPSILON )
        discard;

    vec3  step1Texture  = startTexture;
    ivec4 step1CellIdx  = provokingVertexIdx;

    vec3  step1CellCenterTexture = vec3( step1CellIdx.xyz + 1 ) * volumeStepf;
    float step1Value    = texture( volumeTexture, step1CellCenterTexture ).r;
          color         = texture( colorMapTexture, TranslateValue( step1Value ) );
          color.rgb    *= color.a;

    ivec4 step2CellIdx;
    float t;
    int intersect = FindNextCell( step1CellIdx, startTexture, rayDirTexture, step2CellIdx, t );

    color = vec4( 0.0 );

    if( intersect == 0 )
        color = vec4( 1.0, 0.2, 0.2, 1.0 );
    else if( intersect == 1 )
        color = vec4( 0.2, 1.0, 0.2, 1.0 );
    else if( intersect > 2 )
        color = vec4( 1.0 );
    

#if 0
    if( CellOutsideBound( step2CellIdx.xyz ) )
    {
        step2CellIdx = step1CellIdx;
    }
    else
    {
        int maxCells     = 2 * int(length( volumeDimsf ));
        int counter;
        for( counter = 0; counter < maxCells; counter++ )
        {
            vec3  step2CellCenterTexture = vec3( step2CellIdx.xyz + 1 ) * volumeStepf;
            float step2Value    = texture( volumeTexture, step2CellCenterTexture ).r;
            vec4  backColor     = texture( colorMapTexture, TranslateValue( step2Value ) );
            color.rgb          += (1.0 - color.a) * backColor.a * backColor.rgb;
            color.a            += (1.0 - color.a) * backColor.a;

            step1CellIdx = step2CellIdx;
            intersect = FindNextCell(  step1CellIdx, startTexture, rayDirTexture, step2CellIdx, t );

            if( CellOutsideBound( step2CellIdx.xyz ) )
            {
                step2CellIdx = step1CellIdx;
                break;
            }
            
        }

        if( !intersect )
            color = vec4( 1.0, 0.2, 0.2, 1.0 );
    }
#endif






#if 0
    float nStepsf       = rayDirLength  / stepSize1D;
    vec3  stepSize3D    = rayDirTexture / nStepsf;

    vec3  step1Texture  = startTexture;
    if( ShouldSkip( step1Texture ) )
    {
        color = vec4( 0.0f );
    }
    else
    {
        float step1Value = texture( volumeTexture, step1Texture ).r;
              color      = texture( colorMapTexture, TranslateValue(step1Value) );
              color.rgb *= color.a;
    }

    // let's do a ray casting! 
    for( int i = 0; i < int(nStepsf); i++ )
    {
        if( color.a > 0.999f )  // You can still see through with 0.99...
            break;

        vec3 step2Texture = startTexture + stepSize3D * float(i + 1);
        if( ShouldSkip( step2Texture ) )
            continue;

        float step2Value  = texture( volumeTexture, step2Texture ).r;
        vec4  backColor   = texture( colorMapTexture, TranslateValue(step2Value) );
        
        // Apply lighting if big enough gradient
        if( lighting )
        {
            vec3 gradientModel = CalculateGradient( step2Texture );
            if( length( gradientModel ) > EPSILON )
            {
                vec3 gradientEye = (transposedInverseMV * vec4( gradientModel, 0.0f )).xyz;
                     gradientEye = normalize( gradientEye );
                float diffuse    = abs( dot(lightDirEye, gradientEye) );

                // Calculate eye space coordinates of "step2Texture"
                vec3 step2Model  = boxMin + step2Texture * (boxMax - boxMin);
                vec3 step2Eye    = (ModelView * vec4(step2Model, 1.0f)).xyz;
                vec3 viewDirEye  = normalize( -step2Eye );

                vec3 reflectionEye = reflect( -lightDirEye, gradientEye );
                float specular   = pow( max(0.0f, dot( reflectionEye, viewDirEye )), specularExp ); 
                backColor.rgb    = backColor.rgb * (ambientCoeff + diffuse * diffuseCoeff) + 
                                   specular * specularCoeff;
            }
        }   // End lighting

        // Color compositing
        color.rgb += (1.0f - color.a) * backColor.a * backColor.rgb;
        color.a   += (1.0f - color.a) * backColor.a;
    }   // End ray casting
#endif

}

