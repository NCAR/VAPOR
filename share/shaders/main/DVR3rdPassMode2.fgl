#version 410 core

in vec4 positionClip;   // vertex position in the clip space
in vec4 positionModel;  // vertex position in the clip space
flat in ivec4 provokingVertexIdx;
layout(location = 0) out vec4 color;

uniform sampler2D       backFaceTexture;
uniform sampler2D       frontFaceTexture;
uniform sampler3D       volumeTexture;
uniform usampler3D      missingValueMaskTexture; // !!unsigned integer!!
uniform sampler1D       colorMapTexture;
uniform samplerBuffer   xyCoordsTexture;
uniform samplerBuffer   zCoordsTexture;

uniform vec2 valueRange;        // min and max values of this variable
uniform vec2 colorMapRange;     // min and max values on this color map
uniform vec3 boxMin;            // min coordinates of the bounding box of this volume
uniform vec3 boxMax;            // max coordinates of the bounding box of this volume
uniform ivec3 volumeDims;       // number of vertices in this volume
uniform vec4 clipPlanes[6];     // clipping planes in **un-normalized** model coordinates

uniform float stepSize1D;       // ray casting step size
uniform bool  lighting;         // apply lighting or not
uniform bool  hasMissingValue;  // has missing values or not
uniform float lightingCoeffs[4]; // lighting parameters

uniform mat4 transposedInverseMV;   // transpose(inverse(ModelView))
uniform mat4 ModelView;

//
// Derive helper variables
//
const float EPSILON  = 5e-6;
float ambientCoeff   = lightingCoeffs[0];
float diffuseCoeff   = lightingCoeffs[1];
float specularCoeff  = lightingCoeffs[2];
float specularExp    = lightingCoeffs[3];
vec3  volumeDimsf    = vec3( float(volumeDims.x), float(volumeDims.y), float(volumeDims.z) );

//
// Input:  normalized value w.r.t. valueRange.
// Output: normalized value w.r.t. colorMapRange.
//
float TranslateValue( const in float value )
{
    float   orig = value * (valueRange.y - valueRange.x) + valueRange.x;
    return (orig - colorMapRange.x) / (colorMapRange.y - colorMapRange.x);
}

//
// Input:  logical index of a vertex
// Output: normalized user coordinate of this vertex
//
vec3 GetCoordinates( const in ivec3 index )
{
    int xyOffset = index.y *  volumeDims.x + index.x;
    int zOffset  = index.z * (volumeDims.x * volumeDims.y) + xyOffset;
    vec4 xyC     = texelFetch( xyCoordsTexture, xyOffset );
    vec4 zC      = texelFetch( zCoordsTexture,  zOffset );
    return vec3( xyC.xy, zC.x );
}

//
// Input:  the coordinates of the current fragment and the provoking vertex.
//         the indices of two vertices: v1 and v2.
// Output: true or false that the current fragment is in between of v1-pv-v2.
//
bool BetweenTwoDirections( const in vec3  fragCoords, const in vec3  pvCoords,
                           const in ivec3 v1Idx,      const in ivec3 v2Idx   )
{
        vec3 v1Coords = GetCoordinates( v1Idx );
        vec3 v2Coords = GetCoordinates( v2Idx );

        vec3 v1Dir = normalize( v1Coords   - pvCoords );
        vec3 v2Dir = normalize( v2Coords   - pvCoords );
        vec3 fgDir = normalize( fragCoords - pvCoords );

        float dot1 = dot( v1Dir, v2Dir );
        float dot2 = 1.0;
        float dotf = dot( fgDir, v2Dir );

        if( dot2 >= dotf && dotf > dot1 )   // fragCoords is between v1 and v2.
            return true;
        else
            return false;
}

//
// Input:  Texture coordinates of the current fragment
// Output: Indication of which of the two triangle that this fragment is in.
//         True == triangle of pv-v1-v2. False == triangle of pv-v1-v3.
//         Please see the diagrams below.
//
bool DistinguishTriangle( const in vec3 fragCoords )
{
    ivec3 pvIdx = provokingVertexIdx.xyz;       // provoking vertex
    vec3  pvCds = GetCoordinates( pvIdx );
    if( provokingVertexIdx.w == 0 )             // front face, z == volumeDims.z - 1
    {
        //               v3 (false)
        //              /|
        //             / |
        //            /  |
        //           /   |
        //          /    |             Y
        //         v1----pv            |
        //         |    /              |
        //         |   /               |
        //         |  /                /-------- X
        //         | /                /
        //         |/                /
        //         v2 (true)        Z  ( Z comes out of the screen )
        //
        ivec3 v1Idx = ivec3( pvIdx.x - 1, pvIdx.y,     pvIdx.z );
        ivec3 v2Idx = ivec3( pvIdx.x - 1, pvIdx.y - 1, pvIdx.z );
        ivec3 v3Idx = ivec3( pvIdx.x,     pvIdx.y + 1, pvIdx.z );
        if( v2Idx.y < 0 )                       // the triangle is pv, v1, v3
            return false;
        else if( v3Idx.y > (volumeDims.y - 1) ) // the triangle is pv, v1, v2
            return true;
        else                                    // real detection work...
        {
            bool v1v2 = BetweenTwoDirections( fragCoords, pvCds, v1Idx, v2Idx );
            return v1v2;
        }
    }
    else if( provokingVertexIdx.w == 1 )    // back face, so z == 0
    {
        //               v3 (false)
        //              /|
        //             / |
        //            /  |
        //           /   |
        //          /    |
        //         pv----v1 
        //         |    /
        //         |   /               Z    Y
        //         |  /                 \   |
        //         | /                   \  |
        //         |/                     \ |
        //         v2 (true)        X _____\|   ( Z goes into the screen )
        //
        ivec3 v1Idx = ivec3( pvIdx.x - 1, pvIdx.y,      pvIdx.z );
        ivec3 v2Idx = ivec3( pvIdx.x,     pvIdx.y - 1,  pvIdx.z );
        ivec3 v3Idx = ivec3( pvIdx.x - 1, pvIdx.y + 1,  pvIdx.z );
        if( v2Idx.y < 0 )
            return false;
        else if( v3Idx.y > (volumeDims.y - 1) )
            return true;
        else
        {
            bool v1v2 = BetweenTwoDirections( fragCoords, pvCds, v1Idx, v2Idx );
            return v1v2;
        }
    }
    else if( provokingVertexIdx.w == 2 )    // right face, so x == volumedims.x - 1
    {
        //               v3 (false)
        //              /|
        //             / |
        //            /  |
        //           /   |
        //          /    |             Z
        //         v1----pv            |
        //         |    /              |
        //         |   /               |
        //         |  /                /-------- Y
        //         | /                /
        //         |/                /
        //         v2 (true)        X  ( X comes out of the screen )
        //
        ivec3 v1Idx = ivec3( pvIdx.x, pvIdx.y - 1, pvIdx.z     );
        ivec3 v2Idx = ivec3( pvIdx.x, pvIdx.y - 1, pvIdx.z - 1 );
        ivec3 v3Idx = ivec3( pvIdx.x, pvIdx.y    , pvIdx.z + 1 );
        if( v2Idx.z < 0 )
            return false;
        else if( v3Idx.z > (volumeDims.z - 1) )
            return true;
        else
        {
            bool v1v2 = BetweenTwoDirections( fragCoords, pvCds, v1Idx, v2Idx );
            return v1v2;
        }
    }
    else if( provokingVertexIdx.w == 3 )    // left face, x == 0
    {
        //               v3 (false)
        //              /|
        //             / |
        //            /  |
        //           /   |
        //          /    |
        //         pv----v1 
        //         |    /
        //         |   /               X    Z
        //         |  /                 \   |
        //         | /                   \  |
        //         |/                     \ |
        //         v2 (true)        Y _____\|   ( X goes into the screen )
        //
        ivec3 v1Idx = ivec3( pvIdx.x, pvIdx.y - 1, pvIdx.z     );
        ivec3 v2Idx = ivec3( pvIdx.x, pvIdx.y,     pvIdx.z - 1 );
        ivec3 v3Idx = ivec3( pvIdx.x, pvIdx.y - 1, pvIdx.z + 1 );
        if( v2Idx.z < 0 )
            return false;
        else if( v3Idx.z > (volumeDims.z - 1) )
            return true;
        else
        {
            bool v1v2 = BetweenTwoDirections( fragCoords, pvCds, v1Idx, v2Idx );
            return v1v2;
        }
    }
    else if( provokingVertexIdx.w == 4 )    // top face, y == volumeDims.y - 1
    {
        //               v3 (false)
        //              /|
        //             / |
        //            /  |
        //           /   |
        //          /    |                      Z
        //         pv----v1                     |
        //         |    /                       |
        //         |   /                        |
        //         |  /                X--------\
        //         | /                           \
        //         |/                             \
        //         v2 (true)                       Y  ( Y comes out of the screen )
        //
        ivec3 v1Idx = ivec3( pvIdx.x - 1, pvIdx.y, pvIdx.z     );
        ivec3 v2Idx = ivec3( pvIdx.x,     pvIdx.y, pvIdx.z - 1 );
        ivec3 v3Idx = ivec3( pvIdx.x - 1, pvIdx.y, pvIdx.z + 1 );
        if( v2Idx.z < 0 )
            return false;
        else if( v3Idx.z > volumeDims.z - 1 )
            return true;
        else
        {
            bool v1v2 = BetweenTwoDirections( fragCoords, pvCds, v1Idx, v2Idx );
            return v1v2;
        }
    }
    else    // bottom face, y == 0
    {
        //               v3 (false)
        //              /|
        //             / |
        //            /  |
        //           /   |
        //          /    |
        //         v1----pv 
        //         |    /               Z     Y (Y goes into the screen)
        //         |   /                |    /
        //         |  /                 |   /
        //         | /                  |  /
        //         |/                   | /
        //         v2 (true)            |/_________ X
        //
        ivec3 v1Idx = ivec3( pvIdx.x - 1, pvIdx.y, pvIdx.z     );
        ivec3 v2Idx = ivec3( pvIdx.x - 1, pvIdx.y, pvIdx.z - 1 );
        ivec3 v3Idx = ivec3( pvIdx.x,     pvIdx.y, pvIdx.z + 1 );
        if( v2Idx.z < 0 )
            return false;
        else if( v3Idx.z > volumeDims.z - 1 )
            return true;
        else
        {
            bool v1v2 = BetweenTwoDirections( fragCoords, pvCds, v1Idx, v2Idx );
            return v1v2;
        }
    }
}

//
// Input:  Location to be evaluated in texture coordinates.
// Output: If this location should be skipped.
// Note:   It is skipped in two cases: 1) it represents a missing value
//                                     2) it is outside of clipping planes
//
bool ShouldSkip( const in vec3 tc )
{
    if( hasMissingValue && (texture(missingValueMaskTexture, tc).r != 0u) )
        return true;

    vec4 positionModel  = vec4( (boxMin + tc * (boxMax - boxMin)), 1.0 );
    for( int i = 0; i < 6; i++ )
    {
        if( dot(positionModel, clipPlanes[i]) < 0.0 )
            return true;
    }

    return false;
}

//
// Input:  Location to be evaluated in texture coordinates
// Output: Gradient at that location
//
vec3 CalculateGradient( const in vec3 tc)
{
    vec3 h0 = vec3(-0.5 ) / volumeDimsf;
    vec3 h1 = vec3( 0.5 ) / volumeDimsf;
    vec3 h  = vec3( 1.0 );

    if ((tc.x + h0.x) < 0.0) {
        h0.x = 0.0;
        h.x = 0.5;
    }
    if ((tc.x + h1.x) > 1.0) {
        h1.x = 0.0;
        h.x = 0.5;
    }
    if ((tc.y + h0.y) < 0.0) {
        h0.y = 0.0;
        h.y = 0.5;
    }
    if ((tc.y + h1.y) > 1.0) {
        h1.y = 0.0;
        h.y = 0.5;
    }
    if ((tc.z + h0.z) < 0.0) {
        h0.z = 0.0;
        h.z = 0.5;
    }
    if ((tc.z + h1.z) > 1.0) {
        h1.z = 0.0;
        h.z = 0.5;
    }

    vec3 a0, a1;
    a0.x = texture( volumeTexture, tc + vec3(h0.x,0.0,0.0) ).r;
    a1.x = texture( volumeTexture, tc + vec3(h1.x,0.0,0.0) ).r;
    a0.y = texture( volumeTexture, tc + vec3(0.0,h0.y,0.0) ).r;
    a1.y = texture( volumeTexture, tc + vec3(0.0,h1.y,0.0) ).r;
    a0.z = texture( volumeTexture, tc + vec3(0.0,0.0,h0.z) ).r;
    a1.z = texture( volumeTexture, tc + vec3(0.0,0.0,h1.z) ).r;

    return (a1-a0 / h);
}

// reference implementation: 
// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection
bool RayTriangleIntersect( const in vec3 orig, const in vec3 dir,
                           const in vec3 v0,   const in vec3 v1,  const in vec3 v2,
                           out float t ) 
{
    vec3 v0v1 = v1 - v0;
    vec3 v0v2 = v2 - v0;
    vec3 pvec = cross( dir, v0v2 );
    float det = dot(  v0v1, pvec );

    if( abs(det) < EPSILON ) // ray and triangle are parallel
        return false;

    float invDet = 1.0 / det;
    vec3  tvec   = orig - v0;
    float u      = dot( tvec, pvec ) * invDet;
    if( u < 0.0 || u > 1.0 )
        return false;

    vec3 qvec    = cross( tvec, v0v1 );
    float v      = dot( dir, qvec ) * invDet;
    if( v < 0.0 || u + v > 1.0 )
        return false;

    t = dot( v0v2, qvec ) * invDet;

    return true;
}


void main(void)
{
    vec3  lightDirEye   = vec3(0.0, 0.0, 1.0); 

    // Get UV coordinates of this frament
    if( positionClip.w == 0.0 )
        discard;
    vec2 positionUV     = ((positionClip.xy / positionClip.w) + 1.0) / 2.0;

    vec3 stopTexture    = texture( backFaceTexture,  positionUV ).xyz;
    vec3 startTexture   = texture( frontFaceTexture, positionUV ).xyz;
    vec3 rayDirTexture  = stopTexture - startTexture;
    float rayDirLength  = length( rayDirTexture );
    if( rayDirLength < EPSILON )
        discard;

    color = vec4( vec3(provokingVertexIdx.rgb) / volumeDimsf, 0.8f );
    bool v2Ques = DistinguishTriangle( startTexture );
    if(  v2Ques )
        color.a = 1.0;
    else
        color.a = 0.5;

#if 0
    float nStepsf       = rayDirLength  / stepSize1D;
    vec3  stepSize3D    = rayDirTexture / nStepsf;

    vec3  step1Texture  = startTexture;
    if( ShouldSkip( step1Texture ) )
    {
        color = vec4( 0.0f );
    }
    else
    {
        float step1Value = texture( volumeTexture, step1Texture ).r;
              color      = texture( colorMapTexture, TranslateValue(step1Value) );
              color.rgb *= color.a;
    }

    // let's do a ray casting! 
    for( int i = 0; i < int(nStepsf); i++ )
    {
        if( color.a > 0.999f )  // You can still see through with 0.99...
            break;

        vec3 step2Texture = startTexture + stepSize3D * float(i + 1);
        if( ShouldSkip( step2Texture ) )
            continue;

        float step2Value  = texture( volumeTexture, step2Texture ).r;
        vec4  backColor   = texture( colorMapTexture, TranslateValue(step2Value) );
        
        // Apply lighting if big enough gradient
        if( lighting )
        {
            vec3 gradientModel = CalculateGradient( step2Texture );
            if( length( gradientModel ) > EPSILON )
            {
                vec3 gradientEye = (transposedInverseMV * vec4( gradientModel, 0.0f )).xyz;
                     gradientEye = normalize( gradientEye );
                float diffuse    = abs( dot(lightDirEye, gradientEye) );

                // Calculate eye space coordinates of "step2Texture"
                vec3 step2Model  = boxMin + step2Texture * (boxMax - boxMin);
                vec3 step2Eye    = (ModelView * vec4(step2Model, 1.0f)).xyz;
                vec3 viewDirEye  = normalize( -step2Eye );

                vec3 reflectionEye = reflect( -lightDirEye, gradientEye );
                float specular   = pow( max(0.0f, dot( reflectionEye, viewDirEye )), specularExp ); 
                backColor.rgb    = backColor.rgb * (ambientCoeff + diffuse * diffuseCoeff) + 
                                   specular * specularCoeff;
            }
        }   // End lighting

        // Color compositing
        color.rgb += (1.0f - color.a) * backColor.a * backColor.rgb;
        color.a   += (1.0f - color.a) * backColor.a;
    }   // End ray casting
#endif

}       // End main()

