#version 410 core

in vec4 positionClip;   // vertex position in the clip space
in vec4 positionModel;  // vertex position in the clip space
flat in ivec4 provokingVertexIdx;
layout(location = 0) out vec4 color;

uniform sampler2D       backFaceTexture;
uniform sampler2D       frontFaceTexture;
uniform sampler3D       volumeTexture;
uniform usampler3D      missingValueMaskTexture; // !!unsigned integer!!
uniform sampler1D       colorMapTexture;
uniform samplerBuffer   xyCoordsTexture;
uniform samplerBuffer   zCoordsTexture;

uniform vec2 valueRange;        // min and max values of this variable
uniform vec2 colorMapRange;     // min and max values on this color map
uniform vec3 boxMin;            // min coordinates of the bounding box of this volume
uniform vec3 boxMax;            // max coordinates of the bounding box of this volume
uniform ivec3 volumeDims;       // number of vertices in this volume
uniform vec4 clipPlanes[6];     // clipping planes in **un-normalized** model coordinates

uniform float stepSize1D;       // ray casting step size
uniform bool  lighting;         // apply lighting or not
uniform bool  hasMissingValue;  // has missing values or not
uniform float lightingCoeffs[4]; // lighting parameters

uniform mat4 transposedInverseMV;   // transpose(inverse(ModelView))
uniform mat4 ModelView;

//
// Derive helper variables
//
const float EPSILON  = 5e-6;
float ambientCoeff   = lightingCoeffs[0];
float diffuseCoeff   = lightingCoeffs[1];
float specularCoeff  = lightingCoeffs[2];
float specularExp    = lightingCoeffs[3];
vec3  volumeDimsf    = vec3( float(volumeDims.x), float(volumeDims.y), float(volumeDims.z) );
vec3  volumeStepf    = 1.0 / volumeDimsf;

//
// Input:  normalized value w.r.t. valueRange.
// Output: normalized value w.r.t. colorMapRange.
//
float TranslateValue( const in float value )
{
    float   orig = value * (valueRange.y - valueRange.x) + valueRange.x;
    return (orig - colorMapRange.x) / (colorMapRange.y - colorMapRange.x);
}

//
// Input:  logical index of a vertex
// Output: normalized user coordinate of this vertex
//
vec3 GetCoordinates( const in ivec3 index )
{
    int xyOffset = index.y *  volumeDims.x + index.x;
    int zOffset  = index.z * (volumeDims.x * volumeDims.y) + xyOffset;
    vec4 xyC     = texelFetch( xyCoordsTexture, xyOffset );
    vec4 zC      = texelFetch( zCoordsTexture,  zOffset );
    return vec3( xyC.xy, zC.x );
}

//
// Input:  Location to be evaluated in texture coordinates.
// Output: If this location should be skipped.
// Note:   It is skipped in two cases: 1) it represents a missing value
//                                     2) it is outside of clipping planes
//
bool ShouldSkip( const in vec3 tc )
{
    if( hasMissingValue && (texture(missingValueMaskTexture, tc).r != 0u) )
        return true;

    vec4 positionModel  = vec4( (boxMin + tc * (boxMax - boxMin)), 1.0 );
    for( int i = 0; i < 6; i++ )
    {
        if( dot(positionModel, clipPlanes[i]) < 0.0 )
            return true;
    }

    return false;
}

//
// Input:  Location to be evaluated in texture coordinates
// Output: Gradient at that location
//
vec3 CalculateGradient( const in vec3 tc)
{
    vec3 h0 = vec3(-0.5 ) / volumeDimsf;
    vec3 h1 = vec3( 0.5 ) / volumeDimsf;
    vec3 h  = vec3( 1.0 );

    if ((tc.x + h0.x) < 0.0) {
        h0.x = 0.0;
        h.x = 0.5;
    }
    if ((tc.x + h1.x) > 1.0) {
        h1.x = 0.0;
        h.x = 0.5;
    }
    if ((tc.y + h0.y) < 0.0) {
        h0.y = 0.0;
        h.y = 0.5;
    }
    if ((tc.y + h1.y) > 1.0) {
        h1.y = 0.0;
        h.y = 0.5;
    }
    if ((tc.z + h0.z) < 0.0) {
        h0.z = 0.0;
        h.z = 0.5;
    }
    if ((tc.z + h1.z) > 1.0) {
        h1.z = 0.0;
        h.z = 0.5;
    }

    vec3 a0, a1;
    a0.x = texture( volumeTexture, tc + vec3(h0.x,0.0,0.0) ).r;
    a1.x = texture( volumeTexture, tc + vec3(h1.x,0.0,0.0) ).r;
    a0.y = texture( volumeTexture, tc + vec3(0.0,h0.y,0.0) ).r;
    a1.y = texture( volumeTexture, tc + vec3(0.0,h1.y,0.0) ).r;
    a0.z = texture( volumeTexture, tc + vec3(0.0,0.0,h0.z) ).r;
    a1.z = texture( volumeTexture, tc + vec3(0.0,0.0,h1.z) ).r;

    return (a1-a0 / h);
}

// reference implementation: 
// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection
bool RayTriangleIntersect( const in vec3 orig, const in vec3 dir,
                           const in vec3 v0,   const in vec3 v1,  const in vec3 v2,
                           out float t,        out float u,       out float v ) 
{
    vec3 v0v1 = v1 - v0;
    vec3 v0v2 = v2 - v0;
    vec3 pvec = cross( dir, v0v2 );
    float det = dot(  v0v1, pvec );

    const float zero = 1e-8;
    if( abs(det) < zero ) // ray and triangle are parallel
    {
        t = 100.0;   u = 100.0;   v = 100.0;
        return false;
    }

    vec3  tvec   = orig - v0;
    vec3  qvec   = cross( tvec, v0v1 );
    u            = dot( tvec, pvec ) / det; // if u == 0, ray hits edge v0v2
    v            = dot( dir,  qvec ) / det; // if v == 0, ray hits edge v0v1
    t            = dot( v0v2, qvec ) / det;

    if( u < 0.0 || v < 0.0 || u > 1.0 || v > 1.0 || u + v > 1.0 )
        return false;
    else
        return true;
}

// From: https://courses.cs.washington.edu/courses/csep557/10au/lectures/triangle_intersection.pdf
bool  RayPlaneIntersect( const in vec3 orig, const in vec3 dir,
                         const in vec3 v0,   const in vec3 v1,  const in vec3 v2,
                         out float t )
{
    vec3 v0v1 = v1 - v0;
    vec3 v0v2 = v2 - v0;
    vec3  n   = cross( v0v2, v0v1 );
    float den = dot( n, dir );
    const float zero = 1e-8;
    if( abs(den) < zero )   // Ray and triangle are parallel
    {
        t = -100.0;
        return false;
    }
    float num = dot( n, v0 - orig );
    t         = num / den;

    return true;
}

float HowMuchOutside( const in float u, const in float v )
{
    float outAmt    = 0.0;
    bool  penalized = false;
    if( u < 0.0 )
        outAmt   += -u;
    else if( u > 1.0 )
    {
        outAmt   += u - 1.0;
        penalized = true;
    }
    
    if( v < 0.0 )
        outAmt   += -v;
    else if( v > 1.0 )
    {
        outAmt   += v - 1.0;
        penalized = true;
    }

    if( !penalized && u + v > 1.0 )
        outAmt  += u + v - 1.0;

    return outAmt;
}


int   FindNextCell( const in ivec4 step1CellIdx,    const in vec3  startTexture,
                    const in  vec3 rayDirTexture,   const in float step1T,
                    out ivec4 step2CellIdx,  out float t,  out float u,  out float v  )
{
    //          Y
    //        4 __________________5
    //         /|               /|
    //        / |              / |
    //       /  |             /  |
    //     7/___|___________6/   |
    //      |   |           |    |
    //      |   |           |    |
    //      |   |___________|____|  X
    //      |   /0          |   /1
    //      |  /            |  /
    //      | /             | /
    //     3|/______________|/    
    //                     2
    //     Z
    ivec3 V0    = step1CellIdx.xyz;

    ivec3 cubeVertIdx[8]; 
    cubeVertIdx[0] = V0;
    cubeVertIdx[1] = ivec3(V0.x + 1, V0.y    , V0.z     );
    cubeVertIdx[2] = ivec3(V0.x + 1, V0.y    , V0.z + 1 );
    cubeVertIdx[3] = ivec3(V0.x    , V0.y    , V0.z + 1 );
    cubeVertIdx[4] = ivec3(V0.x    , V0.y + 1, V0.z     );
    cubeVertIdx[5] = ivec3(V0.x + 1, V0.y + 1, V0.z     );
    cubeVertIdx[6] = ivec3(V0.x + 1, V0.y + 1, V0.z + 1 );
    cubeVertIdx[7] = ivec3(V0.x    , V0.y + 1, V0.z + 1 );

    vec3 cubeVertCoords[8];
    for( int i = 0; i < 8; i++ )
        cubeVertCoords[i] = GetCoordinates( cubeVertIdx[i] );

    ivec3 triangles[12];
    triangles[0]  =  ivec3( 7, 3, 6 );  // front face,  w == 0
    triangles[1]  =  ivec3( 2, 3, 6 );
    triangles[2]  =  ivec3( 0, 4, 1 );  // back face,   w == 1
    triangles[3]  =  ivec3( 5, 4, 1 );
    triangles[4]  =  ivec3( 4, 7, 5 );  // top face,    w == 2
    triangles[5]  =  ivec3( 6, 7, 5 );
    triangles[6]  =  ivec3( 3, 0, 2 );  // bottom face, w == 3
    triangles[7]  =  ivec3( 1, 0, 2 );
    triangles[8]  =  ivec3( 5, 1, 6 );  // right face,  w == 4
    triangles[9]  =  ivec3( 2, 1, 6 );
    triangles[10] =  ivec3( 4, 0, 7 );  // left face,   w == 5
    triangles[11] =  ivec3( 3, 0, 7 );

    // Test intersection with 12 triangles
    bool  intersect[12];
    float tArr[12],    uArr[12],   vArr[12];
    for( int i = 0; i < 12; i++ )
    {
        intersect[i] = RayPlaneIntersect( startTexture,   rayDirTexture,
                                          cubeVertCoords[ triangles[i][0] ],
                                          cubeVertCoords[ triangles[i][1] ],
                                          cubeVertCoords[ triangles[i][2] ],
                                          tArr[i]                         );
    }

    // Extract which 2 faces the ray is coming in.
    //   If the ray comes in from a face, this vector holds 2 values that are identical.
    //   Otherwise, it has 2 faces that forms an edge.
    int inFace[2];
    if( step1CellIdx.w < 10 )       // A face
    {
        inFace[0] = step1CellIdx.w;
        inFace[1] = step1CellIdx.w;
    }
    else                            // An edge
    {
        inFace[0] = step1CellIdx.w / 10 - 1;
        inFace[1] = int( mod( float(step1CellIdx.w), 10.0 ) );
    }

    // Find the smallest t that's larger than step1T
    const float zero  = 1e-6;
    float smallestT   = 100.0;
    for( int i = 0; i < 12; i++ )
    {
        if( (i / 2 != inFace[0])        && (i / 2 != inFace[1])   &&
            (tArr[i] - step1T > -zero ) && (tArr[i] < smallestT)   )
            smallestT = tArr[i];
    }
    t = smallestT;

    int  numSmallestT = 0;
    int  exitFaces[6] = int[]( -1, -1, -1, -1, -1, -1 );
    for( int i = 0; i < 6; i++ )
    {
        if( (i != inFace[0]) && (i != inFace[1]) &&
            (abs(tArr[2*i] - smallestT) < zero || abs(tArr[2*i+1] - smallestT) < zero) )
        {
            exitFaces[ numSmallestT ] = i;
            numSmallestT++;
        }
    }

    if( numSmallestT == 1 )
    {
        int f0 = exitFaces[0];

        switch( f0 )
        {
            case 0:                     // exits the front face of current cell
            {                           // enters the back face of the next cell
                step2CellIdx = ivec4( cubeVertIdx[3], 1 );
                break;
            }
            case 1:                     // exits the back face of current cell
            {                           // enters the front face of the next cell
                step2CellIdx = ivec4( V0.x, V0.y, V0.z - 1, 0 );
                break;
            }
            case 4:                     // exits the right face of current cell
            {                           // enters the left face of the next cell
                step2CellIdx = ivec4( cubeVertIdx[1], 5 );
                break;
            }
            case 5:                     // exits the left face of current cell
            {                           // enters the right face of the next cell
                step2CellIdx = ivec4( V0.x - 1, V0.y, V0.z, 4 );
                break;
            }
            case 2:                     // exits the top face of current cell
            {                           // enters the bottom face of the next cell
                step2CellIdx = ivec4(  cubeVertIdx[4], 3 );
                break;
            }
            case 3:                     // exits the bottom face of current cell
            {                           // enters the top face of the next cell
                step2CellIdx = ivec4( V0.x, V0.y - 1, V0.z, 2 );
                break;
            }
            default: 
            {
                step2CellIdx = ivec4( -10 );
            }
        }
    }
    else if ( numSmallestT == 2 )
    {
        // First record the largest t value
        int   f0     = exitFaces[0];
        int   f1     = exitFaces[1];

        // Second derive the next step cell
        if( f0 == 0 && f1 == 2 )            // exits edge 7-6
        {                                   // enters edge 0-1
            int back = 1, bottom = 3;
            int edge = (back + 1) * 10 + bottom;
            step2CellIdx = ivec4( cubeVertIdx[7], edge );
        }
        else if( f0 == 0 && f1 == 3 )       // exits edge 3-2
        {                                   // enters edge 4-5
            int back = 1, top = 2;
            int edge = (back + 1) * 10 + top;
            step2CellIdx = ivec4( V0.x, V0.y - 1, V0.z + 1, edge );
        }
        else if( f0 == 0 && f1 == 4 )       // exits edge 6-2
        {                                   // enters edge 4-0
            int back = 1, left = 5;
            int edge = (back + 1) * 10 + left;
            step2CellIdx = ivec4( V0.x + 1, V0.y, V0.z + 1, edge );
        }
        else if( f0 == 0 && f1 == 5 )       // exits edge 7-3
        {                                   // enters edge 5-1
            int back = 1, right = 4;
            int edge = (back + 1) * 10 + right;
            step2CellIdx = ivec4( V0.x - 1, V0.y, V0.z + 1, edge );
        }
        else if( f0 == 1 && f1 == 2 )       // exits edge 4-5
        {                                   // enters edge 3-2
            int front = 0, bottom = 3;
            int edge  = (front + 1) * 10 + bottom;
            step2CellIdx = ivec4( V0.x, V0.y + 1, V0.z - 1, edge );
        }
        else if( f0 == 1 && f1 == 3 )       // exits edge 0-1
        {                                   // enters edge 7-6
            int front = 0, top = 2;
            int edge  = (front + 1) * 10 + top;
            step2CellIdx = ivec4( V0.x, V0.y - 1, V0.z - 1, edge );
        }
        else if( f0 == 1 && f1 == 4 )       // exits edge 5-1
        {                                   // enters edge 7-3
            int front = 0, left = 5;
            int edge  = (front + 1) * 10 + left;
            step2CellIdx = ivec4( V0.x + 1, V0.y, V0.z - 1, edge );
        }
        else if( f0 == 1 && f1 == 5 )       // exits edge 4-0
        {                                   // enters edge 6-2
            int front = 0, right = 4;
            int edge  = (front + 1) * 10 + right;
            step2CellIdx = ivec4( V0.x - 1, V0.y, V0.z - 1, edge );
        }
        else if( f0 == 2 && f1 == 5 )       // exits edge 4-7
        {                                   // enters edge 1-2
            int bottom = 3, right = 4;
            int edge   = (bottom + 1) * 10 + right;
            step2CellIdx = ivec4( V0.x - 1, V0.y + 1, V0.z, edge );
        }
        else if( f0 == 2 && f1 == 4 )       // exits edge 5-6
        {                                   // enters edge 0-3
            int bottom = 3, left = 5;
            int edge   = (bottom + 1) * 10 + left;
            step2CellIdx = ivec4( V0.x + 1, V0.y + 1, V0.z, edge );
        }
        else if( f0 == 3 && f1 == 5 )       // exits edge 0-3
        {                                   // enters edge 5-6
            int top  = 2, right = 4;
            int edge = (top + 1) * 10 + right;
            step2CellIdx = ivec4( V0.x - 1, V0.y - 1, V0.z, edge );
        }
        else if( f0 == 3 && f1 == 4 )       // exits edge 1-2
        {                                   // enters edge 4-7
            int top  = 2, left = 5;
            int edge = (top + 1) * 10 + left;
            step2CellIdx = ivec4( V0.x + 1, V0.y - 1, V0.z, edge );
        }
        else
            step2CellIdx = ivec4( -10 );
    }
    else
    {

    }
    
    //u = uArr[exitI];
    //v = vArr[exitI];

    return numSmallestT;
}

bool CellOutsideBound( const in ivec3 cellIdx )
{
    if( cellIdx.x < 0 || cellIdx.x > volumeDims.x - 2 || 
        cellIdx.y < 0 || cellIdx.y > volumeDims.y - 2 ||
        cellIdx.z < 0 || cellIdx.z > volumeDims.z - 2   )
        return true;
    else
        return false;
}

void main(void)
{
    vec3  lightDirEye   = vec3(0.0, 0.0, 1.0); 

    // Get UV coordinates of this frament
    if( abs(positionClip.w) < EPSILON )
        discard;
    vec2 positionUV     = ((positionClip.xy / positionClip.w) + 1.0) / 2.0;

    vec3 stopTexture    = texture( backFaceTexture,  positionUV ).xyz;
    vec3 startTexture   = texture( frontFaceTexture, positionUV ).xyz;
    vec3 rayDirTexture  = stopTexture - startTexture;
    float rayDirLength  = length( rayDirTexture );
    if( rayDirLength < EPSILON )
        discard;

    vec3  step1Texture  = startTexture;
    ivec4 step1CellIdx  = provokingVertexIdx;

    vec3  step1CellCenterTexture = vec3( step1CellIdx.xyz + 1 ) * volumeStepf;
    float step1Value    = texture( volumeTexture, step1CellCenterTexture ).r;
          color         = texture( colorMapTexture, TranslateValue( step1Value ) );
          color.rgb    *= color.a;

    ivec4 step2CellIdx = ivec4( 0 );
    float step1T, step2T,  u,  v;
    int intersect = FindNextCell( step1CellIdx, startTexture, rayDirTexture, 
                                  0.0, step2CellIdx, step2T, u, v );
    
    // Ray starts from an edge, and technically not entering the surface cell... 
    const float zero = 1e-6;
    if( step2T < zero )
    {
        int inFace0 = min( step1CellIdx.w, step2CellIdx.w );
        int inFace1 = max( step1CellIdx.w, step2CellIdx.w );
        int inEdge  = (inFace0 + 1) * 10 + inFace1;
        step2CellIdx.w = inEdge;
    }

    if( !CellOutsideBound( step2CellIdx.xyz ) )
    {
        int  maxCells = 2 * int(length( volumeDimsf ));
        int  counter;
        for( counter = 0; counter < maxCells; counter++ )
        {
            vec3  step2CellCenterTexture = vec3( step2CellIdx.xyz + 1 ) * volumeStepf;
            float step2Value    = texture( volumeTexture, step2CellCenterTexture ).r;
            vec4  backColor     = texture( colorMapTexture, TranslateValue( step2Value ) );
            color.rgb          += (1.0 - color.a) * backColor.a * backColor.rgb;
            color.a            += (1.0 - color.a) * backColor.a;

            step1CellIdx = step2CellIdx;
            step1T       = step2T;
            intersect = FindNextCell( step1CellIdx, startTexture, rayDirTexture, 
                                      step1T, step2CellIdx, step2T, u, v );

            if( CellOutsideBound( step2CellIdx.xyz ) )
            {
                step2CellIdx = step1CellIdx;
                break;
            }
        }
    }


#if 0
    float nStepsf       = rayDirLength  / stepSize1D;
    vec3  stepSize3D    = rayDirTexture / nStepsf;

    vec3  step1Texture  = startTexture;
    if( ShouldSkip( step1Texture ) )
    {
        color = vec4( 0.0f );
    }
    else
    {
        float step1Value = texture( volumeTexture, step1Texture ).r;
              color      = texture( colorMapTexture, TranslateValue(step1Value) );
              color.rgb *= color.a;
    }

    // let's do a ray casting! 
    for( int i = 0; i < int(nStepsf); i++ )
    {
        if( color.a > 0.999f )  // You can still see through with 0.99...
            break;

        vec3 step2Texture = startTexture + stepSize3D * float(i + 1);
        if( ShouldSkip( step2Texture ) )
            continue;

        float step2Value  = texture( volumeTexture, step2Texture ).r;
        vec4  backColor   = texture( colorMapTexture, TranslateValue(step2Value) );
        
        // Apply lighting if big enough gradient
        if( lighting )
        {
            vec3 gradientModel = CalculateGradient( step2Texture );
            if( length( gradientModel ) > EPSILON )
            {
                vec3 gradientEye = (transposedInverseMV * vec4( gradientModel, 0.0f )).xyz;
                     gradientEye = normalize( gradientEye );
                float diffuse    = abs( dot(lightDirEye, gradientEye) );

                // Calculate eye space coordinates of "step2Texture"
                vec3 step2Model  = boxMin + step2Texture * (boxMax - boxMin);
                vec3 step2Eye    = (ModelView * vec4(step2Model, 1.0f)).xyz;
                vec3 viewDirEye  = normalize( -step2Eye );

                vec3 reflectionEye = reflect( -lightDirEye, gradientEye );
                float specular   = pow( max(0.0f, dot( reflectionEye, viewDirEye )), specularExp ); 
                backColor.rgb    = backColor.rgb * (ambientCoeff + diffuse * diffuseCoeff) + 
                                   specular * specularCoeff;
            }
        }   // End lighting

        // Color compositing
        color.rgb += (1.0f - color.a) * backColor.a * backColor.rgb;
        color.a   += (1.0f - color.a) * backColor.a;
    }   // End ray casting
#endif

}

