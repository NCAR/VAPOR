#version 410 core

in vec4 positionClip;   // vertex position in the clip space
in vec4 positionModel;  // vertex position in the clip space
flat in ivec4 provokingVertexIdx;
layout(location = 0) out vec4 color;

uniform sampler2D       backFaceTexture;
uniform sampler2D       frontFaceTexture;
uniform sampler3D       volumeTexture;
uniform usampler3D      missingValueMaskTexture; // !!unsigned integer!!
uniform sampler1D       colorMapTexture;
uniform samplerBuffer   xyCoordsTexture;
uniform samplerBuffer   zCoordsTexture;

uniform vec2 valueRange;        // min and max values of this variable
uniform vec2 colorMapRange;     // min and max values on this color map
uniform vec3 boxMin;            // min coordinates of the bounding box of this volume
uniform vec3 boxMax;            // max coordinates of the bounding box of this volume
uniform ivec3 volumeDims;       // number of vertices in this volume
uniform vec4 clipPlanes[6];     // clipping planes in **un-normalized** model coordinates

uniform float stepSize1D;       // ray casting step size
uniform bool  lighting;         // apply lighting or not
uniform bool  hasMissingValue;  // has missing values or not
uniform float lightingCoeffs[4]; // lighting parameters

uniform mat4 transposedInverseMV;   // transpose(inverse(ModelView))
uniform mat4 ModelView;

//
// Derive helper variables
//
const float EPSILON  = 5e-6;
float ambientCoeff   = lightingCoeffs[0];
float diffuseCoeff   = lightingCoeffs[1];
float specularCoeff  = lightingCoeffs[2];
float specularExp    = lightingCoeffs[3];
vec3  volumeDimsf    = vec3( float(volumeDims.x), float(volumeDims.y), float(volumeDims.z) );
vec3  volumeStepf    = 1.0 / volumeDimsf;

//
// Input:  normalized value w.r.t. valueRange.
// Output: normalized value w.r.t. colorMapRange.
//
float TranslateValue( const in float value )
{
    float   orig = value * (valueRange.y - valueRange.x) + valueRange.x;
    return (orig - colorMapRange.x) / (colorMapRange.y - colorMapRange.x);
}

//
// Input:  logical index of a vertex
// Output: normalized user coordinate of this vertex
//
vec3 GetCoordinates( const in ivec3 index )
{
    int xyOffset = index.y *  volumeDims.x + index.x;
    int zOffset  = index.z * (volumeDims.x * volumeDims.y) + xyOffset;
    vec4 xyC     = texelFetch( xyCoordsTexture, xyOffset );
    vec4 zC      = texelFetch( zCoordsTexture,  zOffset );
    return vec3( xyC.xy, zC.x );
}

//
// Input:  Location to be evaluated in texture coordinates.
// Output: If this location should be skipped.
// Note:   It is skipped in two cases: 1) it represents a missing value
//                                     2) it is outside of clipping planes
//
bool ShouldSkip( const in vec3 tc )
{
    if( hasMissingValue && (texture(missingValueMaskTexture, tc).r != 0u) )
        return true;

    vec4 positionModel  = vec4( (boxMin + tc * (boxMax - boxMin)), 1.0 );
    for( int i = 0; i < 6; i++ )
    {
        if( dot(positionModel, clipPlanes[i]) < 0.0 )
            return true;
    }

    return false;
}

//
// Input:  Location to be evaluated in texture coordinates
// Output: Gradient at that location
//
vec3 CalculateGradient( const in vec3 tc)
{
    vec3 h0 = vec3(-0.5 ) / volumeDimsf;
    vec3 h1 = vec3( 0.5 ) / volumeDimsf;
    vec3 h  = vec3( 1.0 );

    if ((tc.x + h0.x) < 0.0) {
        h0.x = 0.0;
        h.x = 0.5;
    }
    if ((tc.x + h1.x) > 1.0) {
        h1.x = 0.0;
        h.x = 0.5;
    }
    if ((tc.y + h0.y) < 0.0) {
        h0.y = 0.0;
        h.y = 0.5;
    }
    if ((tc.y + h1.y) > 1.0) {
        h1.y = 0.0;
        h.y = 0.5;
    }
    if ((tc.z + h0.z) < 0.0) {
        h0.z = 0.0;
        h.z = 0.5;
    }
    if ((tc.z + h1.z) > 1.0) {
        h1.z = 0.0;
        h.z = 0.5;
    }

    vec3 a0, a1;
    a0.x = texture( volumeTexture, tc + vec3(h0.x,0.0,0.0) ).r;
    a1.x = texture( volumeTexture, tc + vec3(h1.x,0.0,0.0) ).r;
    a0.y = texture( volumeTexture, tc + vec3(0.0,h0.y,0.0) ).r;
    a1.y = texture( volumeTexture, tc + vec3(0.0,h1.y,0.0) ).r;
    a0.z = texture( volumeTexture, tc + vec3(0.0,0.0,h0.z) ).r;
    a1.z = texture( volumeTexture, tc + vec3(0.0,0.0,h1.z) ).r;

    return (a1-a0 / h);
}

// reference implementation: 
// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection
bool RayTriangleIntersect( const in vec3 orig, const in vec3 dir,
                           const in vec3 v0,   const in vec3 v1,  const in vec3 v2,
                           out float t,        out float u,       out float v ) 
{
    vec3 v0v1 = v1 - v0;
    vec3 v0v2 = v2 - v0;
    vec3 pvec = cross( dir, v0v2 );
    float det = dot(  v0v1, pvec );

    const float zero = 1e-8;
    if( abs(det) < zero ) // ray and triangle are parallel
    {
        t = 100.0;   u = 100.0;   v = 100.0;
        return false;
    }

    float invDet = 1.0 / det;
    vec3  tvec   = orig - v0;
    u            = dot( tvec, pvec ) * invDet;  // if u == 0, ray hits edge v0v2
    vec3 qvec    = cross( tvec, v0v1 );
    v            = dot( dir, qvec ) * invDet;   // if v == 0, ray hits edge v0v1
    t            = dot( v0v2, qvec ) * invDet;

    if( u < 0.0 || v < 0.0 || u + v > 1.0 )
        return false;
    else
        return true;
}

float HowMuchOutside( const in float u, const in float v )
{
    float outAmt    = 0.0;
    bool  penalized = false;
    if( u < 0.0 )
        outAmt   += -u;
    else if( u > 1.0 )
    {
        outAmt   += u - 1.0;
        penalized = true;
    }
    
    if( v < 0.0 )
        outAmt   += -v;
    else if( v > 1.0 )
    {
        outAmt   += v - 1.0;
        penalized = true;
    }

    if( !penalized && u + v > 1.0 )
        outAmt  += u + v - 1.0;

    return outAmt;
}


int   FindNextCell( const in ivec4 step1CellIdx,    const in vec3 startTexture,
                    const in  vec3 rayDirTexture,   out     ivec4 step2CellIdx,    
                    out float t,  out float u,  out float v  )
{
    //          Y
    //        4 __________________5
    //         /|               /|
    //        / |              / |
    //       /  |             /  |
    //     7/___|___________6/   |
    //      |   |           |    |
    //      |   |           |    |
    //      |   |___________|____|  X
    //      |   /0          |   /1
    //      |  /            |  /
    //      | /             | /
    //     3|/______________|/    
    //                     2
    //     Z
    ivec3 V0    = step1CellIdx.xyz;
    int inFace  = step1CellIdx.w; 

    ivec3 cubeVertIdx[8]; 
    cubeVertIdx[0] = V0;
    cubeVertIdx[1] = ivec3(V0.x + 1, V0.y    , V0.z     );
    cubeVertIdx[2] = ivec3(V0.x + 1, V0.y    , V0.z + 1 );
    cubeVertIdx[3] = ivec3(V0.x    , V0.y    , V0.z + 1 );
    cubeVertIdx[4] = ivec3(V0.x    , V0.y + 1, V0.z     );
    cubeVertIdx[5] = ivec3(V0.x + 1, V0.y + 1, V0.z     );
    cubeVertIdx[6] = ivec3(V0.x + 1, V0.y + 1, V0.z + 1 );
    cubeVertIdx[7] = ivec3(V0.x    , V0.y + 1, V0.z + 1 );

    vec3 cubeVertCoords[8];
    for( int i = 0; i < 8; i++ )
        cubeVertCoords[i] = GetCoordinates( cubeVertIdx[i] );

    ivec3 triangles[12];
    triangles[0]  =  ivec3( 7, 3, 6 );  // front face,  w == 0
    triangles[1]  =  ivec3( 2, 3, 6 );
    triangles[2]  =  ivec3( 0, 4, 1 );  // back face,   w == 1
    triangles[3]  =  ivec3( 5, 4, 1 );
    triangles[4]  =  ivec3( 4, 7, 5 );  // top face,    w == 2
    triangles[5]  =  ivec3( 6, 7, 5 );
    triangles[6]  =  ivec3( 3, 0, 2 );  // bottom face, w == 3
    triangles[7]  =  ivec3( 1, 0, 2 );
    triangles[8]  =  ivec3( 5, 1, 6 );  // right face,  w == 4
    triangles[9]  =  ivec3( 2, 1, 6 );
    triangles[10] =  ivec3( 4, 0, 7 );  // left face,   w == 5
    triangles[11] =  ivec3( 3, 0, 7 );

    // Test intersection with 12 triangles
    bool  intersect[12];
    float tArr[12],    uArr[12],   vArr[12];
    for( int i = 0; i < 12; i++ )
    {
        intersect[i] = RayTriangleIntersect( startTexture,   rayDirTexture,
                                             cubeVertCoords[ triangles[i][0] ],
                                             cubeVertCoords[ triangles[i][1] ],
                                             cubeVertCoords[ triangles[i][2] ],
                                             tArr[i],  uArr[i],  vArr[i]     );
    }

    // Bring back the entry hit, if missing
    if( !intersect[ 2*inFace ] && !intersect[ 2*inFace+1 ] )
    {
        float t1OutAmt = HowMuchOutside( uArr[ 2*inFace   ], vArr[ 2*inFace ] );
        float t2OutAmt = HowMuchOutside( uArr[ 2*inFace+1 ], vArr[ 2*inFace+1 ] );
        
        if( t1OutAmt < t2OutAmt )
            intersect[ 2*inFace ] = true;
        else
            intersect[ 2*inFace+1 ] = true;
    }

    // Bring back the exit hit, if missing
    bool hasExitHit = false;
    for( int i = 0; i < 12; i++ )
    {
        if( intersect[i] && i / 2 != inFace )
        {
            hasExitHit = true;
            break;
        }
    }
    if( !hasExitHit )
    {
        int   triangle = -1;
        float minDiff  = 1.0;  
        for(  int i = 0; i < 12; i++ )
        {
            float diff;
            if( i / 2 != inFace )
            {
                diff = abs( uArr[i] - 1.0 );
                diff = min( diff, abs( vArr[i] - 1.0 ) );
                diff = min( diff, abs( uArr[i] + vArr[i] - 1.0 ) );
                if( diff < minDiff )
                {
                    minDiff  = diff;
                    triangle = i;
                }
            }
        }
    
        intersect[ triangle ] = true;
    }

    // Count the number of intersections after all the treatments
    int counter = 0;
    for( int i = 0; i < 12; i++ )
    {
        if( intersect[i] )
            counter++;
    }

    // Exit hit elimination, where the exit point with the largest t is kept.
    if( counter > 2 )
    {
        float maxT  = -1.0;
        int   exitI = -1;
        for( int i = 0; i < 12; i++ )           // Find the largest T
        {
            if( intersect[i] && i/2 != inFace && tArr[i] > maxT )
            {
                maxT  = tArr[i];
                exitI = i;
            }
        }
        
        for( int i = 0; i < 12; i++ )           // Mark every other intersection as false
        {
            if( i/2 != inFace && i != exitI )
                intersect[i] = false;
        }

        // Re-count the number of intersections after all the treatments
        counter = 0;
        for( int i = 0; i < 12; i++ )
        {
            if( intersect[i] )
                counter++;
        }
    }

    // Entry hit elimination, where the entry point with the smallest t is kept
    if( counter > 2 )
    {
        float minT   = 10.0;
        int   entryI = -1;
        for( int i = 2*inFace; i <= 2*inFace+1; i++ )
        {
            if( intersect[i] && tArr[i] < minT )
            {
                minT   = tArr[i];
                entryI = i;
            }
        }
        for( int i = 2*inFace; i <= 2*inFace+1; i++ )
        {
            intersect[i] = (i == entryI);
        }

        // Re-count the number of intersections after all the treatments
        counter = 0;
        for( int i = 0; i < 12; i++ )
        {
            if( intersect[i] )
                counter++;
        }
    }

    int exitI;
    for( exitI = 0; exitI < 12; exitI++ )   // find the exit face
    {
        if( intersect[exitI] && exitI / 2 != inFace )
            break;
    }

    if( exitI / 2 == 0 )        // exits the front face of current cell
    {                           // enters the back face of the next cell
        step2CellIdx = ivec4( cubeVertIdx[3], 1 );
    }
    else if( exitI / 2 == 1 )   // exits the back face of current cell
    {                           // enters the front face of the next cell
        step2CellIdx = ivec4( V0.x, V0.y, V0.z - 1, 0 );
    }
    else if( exitI / 2 == 4 )   // exits the right face of current cell
    {                           // enters the left face of the next cell
        step2CellIdx = ivec4( cubeVertIdx[1], 5 );
    }
    else if( exitI / 2 == 5 )   // exits the left face of current cell
    {                           // enters the right face of the next cell
        step2CellIdx = ivec4( V0.x - 1, V0.y, V0.z, 4 );
    }
    else if( exitI / 2 == 2 )   // exits the top face of current cell
    {                           // enters the bottom face of the next cell
        step2CellIdx = ivec4(  cubeVertIdx[4], 3 );
    }
    else //( exitI / 2 == 3)    // exits the bottom face of current cell
    {                           // enters the top face of the next cell
        step2CellIdx = ivec4( V0.x, V0.y - 1, V0.z, 2 );
    }
    
    t = tArr[exitI];
    u = uArr[exitI];
    v = vArr[exitI];

    return counter;
}

bool CellOutsideBound( const in ivec3 cellIdx )
{
    if( cellIdx.x < 0 || cellIdx.x > volumeDims.x - 2 || 
        cellIdx.y < 0 || cellIdx.y > volumeDims.y - 2 ||
        cellIdx.z < 0 || cellIdx.z > volumeDims.z - 2   )
        return true;
    else
        return false;
}

void main(void)
{
    vec3  lightDirEye   = vec3(0.0, 0.0, 1.0); 

    // Get UV coordinates of this frament
    if( abs(positionClip.w) < EPSILON )
        discard;
    vec2 positionUV     = ((positionClip.xy / positionClip.w) + 1.0) / 2.0;

    vec3 stopTexture    = texture( backFaceTexture,  positionUV ).xyz;
    vec3 startTexture   = texture( frontFaceTexture, positionUV ).xyz;
    vec3 rayDirTexture  = stopTexture - startTexture;
    float rayDirLength  = length( rayDirTexture );
    if( rayDirLength < EPSILON )
        discard;

    vec3  step1Texture  = startTexture;
    ivec4 step1CellIdx  = provokingVertexIdx;

    vec3  step1CellCenterTexture = vec3( step1CellIdx.xyz + 1 ) * volumeStepf;
    float step1Value    = texture( volumeTexture, step1CellCenterTexture ).r;
          color         = texture( colorMapTexture, TranslateValue( step1Value ) );
          color.rgb    *= color.a;

    ivec4 step2CellIdx;
    float t,  u,  v;
    int intersect = FindNextCell( step1CellIdx, startTexture, rayDirTexture, 
                                  step2CellIdx, t, u, v );

    if( CellOutsideBound( step2CellIdx.xyz ) )
    {
        step2CellIdx = step1CellIdx;
    }
    else
    {
        int maxCells = 2 * int(length( volumeDimsf ));
        int counter;
        for( counter = 0; counter < maxCells; counter++ )
        {
            vec3  step2CellCenterTexture = vec3( step2CellIdx.xyz + 1 ) * volumeStepf;
            float step2Value    = texture( volumeTexture, step2CellCenterTexture ).r;
            vec4  backColor     = texture( colorMapTexture, TranslateValue( step2Value ) );
            color.rgb          += (1.0 - color.a) * backColor.a * backColor.rgb;
            color.a            += (1.0 - color.a) * backColor.a;

            // Start error detection
            /* if( intersect == 0 )
            {
                color = vec4( 1.0, 0.2, 0.2, 1.0 );
                break;
            }
            else if( intersect == 1 )
            {
                color = vec4( 0.2, 1.0, 0.2, 1.0 );
                break;
            }
            else if( intersect > 2 )
            {
                color = vec4( 1.0 );
                break;
            }*/
            // Finish error detection

            step1CellIdx = step2CellIdx;
            intersect = FindNextCell( step1CellIdx, startTexture, rayDirTexture, 
                                      step2CellIdx, t, u, v );

            if( CellOutsideBound( step2CellIdx.xyz ) )
            {
                step2CellIdx = step1CellIdx;
                // debug
                //if( counter < 1 )
                //    color = vec4( 1.0, 0.2, 0.2, 1.0 );
                // finish debug
                break;
            }
            
        }
    }






#if 0
    float nStepsf       = rayDirLength  / stepSize1D;
    vec3  stepSize3D    = rayDirTexture / nStepsf;

    vec3  step1Texture  = startTexture;
    if( ShouldSkip( step1Texture ) )
    {
        color = vec4( 0.0f );
    }
    else
    {
        float step1Value = texture( volumeTexture, step1Texture ).r;
              color      = texture( colorMapTexture, TranslateValue(step1Value) );
              color.rgb *= color.a;
    }

    // let's do a ray casting! 
    for( int i = 0; i < int(nStepsf); i++ )
    {
        if( color.a > 0.999f )  // You can still see through with 0.99...
            break;

        vec3 step2Texture = startTexture + stepSize3D * float(i + 1);
        if( ShouldSkip( step2Texture ) )
            continue;

        float step2Value  = texture( volumeTexture, step2Texture ).r;
        vec4  backColor   = texture( colorMapTexture, TranslateValue(step2Value) );
        
        // Apply lighting if big enough gradient
        if( lighting )
        {
            vec3 gradientModel = CalculateGradient( step2Texture );
            if( length( gradientModel ) > EPSILON )
            {
                vec3 gradientEye = (transposedInverseMV * vec4( gradientModel, 0.0f )).xyz;
                     gradientEye = normalize( gradientEye );
                float diffuse    = abs( dot(lightDirEye, gradientEye) );

                // Calculate eye space coordinates of "step2Texture"
                vec3 step2Model  = boxMin + step2Texture * (boxMax - boxMin);
                vec3 step2Eye    = (ModelView * vec4(step2Model, 1.0f)).xyz;
                vec3 viewDirEye  = normalize( -step2Eye );

                vec3 reflectionEye = reflect( -lightDirEye, gradientEye );
                float specular   = pow( max(0.0f, dot( reflectionEye, viewDirEye )), specularExp ); 
                backColor.rgb    = backColor.rgb * (ambientCoeff + diffuse * diffuseCoeff) + 
                                   specular * specularCoeff;
            }
        }   // End lighting

        // Color compositing
        color.rgb += (1.0f - color.a) * backColor.a * backColor.rgb;
        color.a   += (1.0f - color.a) * backColor.a;
    }   // End ray casting
#endif

}

