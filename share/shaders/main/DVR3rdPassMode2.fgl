#version 410 core

in vec4 positionClip;   // vertex position in the clip space
in vec4 positionModel;  // vertex position in the clip space
flat in ivec4 provokingVertexIdx;
layout(location = 0) out vec4 color;

uniform sampler2D       backFaceTexture;
uniform sampler2D       frontFaceTexture;
uniform sampler3D       volumeTexture;
uniform usampler3D      missingValueMaskTexture; // !!unsigned integer!!
uniform sampler1D       colorMapTexture;
uniform samplerBuffer   xyCoordsTexture;
uniform samplerBuffer   zCoordsTexture;

uniform vec2 valueRange;        // min and max values of this variable
uniform vec2 colorMapRange;     // min and max values on this color map
uniform vec3 boxMin;            // min coordinates of the bounding box of this volume
uniform vec3 boxMax;            // max coordinates of the bounding box of this volume
uniform ivec3 volumeDims;       // number of vertices in this volume
uniform vec4 clipPlanes[6];     // clipping planes in **un-normalized** model coordinates

uniform float stepSize1D;       // ray casting step size
uniform bool  lighting;         // apply lighting or not
uniform bool  hasMissingValue;  // has missing values or not
uniform float lightingCoeffs[4]; // lighting parameters

uniform mat4 transposedInverseMV;   // transpose(inverse(ModelView))
uniform mat4 ModelView;

//
// Derive helper variables
//
const float EPSILON  = 5e-6;
float ambientCoeff   = lightingCoeffs[0];
float diffuseCoeff   = lightingCoeffs[1];
float specularCoeff  = lightingCoeffs[2];
float specularExp    = lightingCoeffs[3];
vec3  volumeDimsf    = vec3( float(volumeDims.x), float(volumeDims.y), float(volumeDims.z) );
vec3  volumeStepf    = 1.0 / volumeDimsf;

//
// Input:  normalized value w.r.t. valueRange.
// Output: normalized value w.r.t. colorMapRange.
//
float TranslateValue( const in float value )
{
    float   orig = value * (valueRange.y - valueRange.x) + valueRange.x;
    return (orig - colorMapRange.x) / (colorMapRange.y - colorMapRange.x);
}

//
// Input:  logical index of a vertex
// Output: normalized user coordinate of this vertex
//
vec3 GetCoordinates( const in ivec3 index )
{
    int xyOffset = index.y *  volumeDims.x + index.x;
    int zOffset  = index.z * (volumeDims.x * volumeDims.y) + xyOffset;
    vec4 xyC     = texelFetch( xyCoordsTexture, xyOffset );
    vec4 zC      = texelFetch( zCoordsTexture,  zOffset );
    return vec3( xyC.xy, zC.x );
}

//
// Input:  the coordinates of the current fragment and the provoking vertex.
//         the indices of two vertices: v1 and v2.
// Output: true or false that the current fragment is in between of v1-pv-v2.
//
bool BetweenTwoDirections( const in vec3  fragCoords, const in vec3  pvCoords,
                           const in ivec3 v1Idx,      const in ivec3 v2Idx   )
{
        vec3 v1Coords = GetCoordinates( v1Idx );
        vec3 v2Coords = GetCoordinates( v2Idx );

        vec3 v1Dir = normalize( v1Coords   - pvCoords );
        vec3 v2Dir = normalize( v2Coords   - pvCoords );
        vec3 fgDir = normalize( fragCoords - pvCoords );

        float dot1 = dot( v1Dir, v2Dir );
        float dot2 = 1.0;
        float dotf = dot( fgDir, v2Dir );

        if( dot2 >= dotf && dotf > dot1 )   // fragCoords is between v1 and v2.
            return true;
        else
            return false;
}

//
// Input:  Texture coordinates of the current fragment
// Output: Logical indices of the current cube (first 3 element),
//         and which face (0-5) does the ray come into this cube (last element).
//
ivec4 GetCellIndices( const in vec3 fragCoords )
{
    ivec3 pvIdx = provokingVertexIdx.xyz;       // provoking vertex
    vec3  pvCds = GetCoordinates( pvIdx );
    bool  v1v2;
    if( provokingVertexIdx.w == 0 )             // front face, z == volumeDims.z - 1
    {
        //               v3 (false)
        //              /|
        //             / |
        //            /  |
        //           /   |
        //          /    |             Y
        //         v1----pv            |
        //         |    /              |
        //         |   /               |
        //         |  /                /-------- X
        //         | /                /
        //         |/                /
        //         v2 (true)        Z  ( Z comes out of the screen )
        //
        ivec3 v1Idx = ivec3( pvIdx.x - 1, pvIdx.y,     pvIdx.z );
        ivec3 v2Idx = ivec3( pvIdx.x - 1, pvIdx.y - 1, pvIdx.z );
        ivec3 v3Idx = ivec3( pvIdx.x,     pvIdx.y + 1, pvIdx.z );
        if( v2Idx.y < 0 )                       // the triangle is pv, v1, v3
            v1v2 = false;
        else if( v3Idx.y > (volumeDims.y - 1) ) // the triangle is pv, v1, v2
            v1v2 = true;
        else                                    // real detection work...
            v1v2 = BetweenTwoDirections( fragCoords, pvCds, v1Idx, v2Idx );
        if( v1v2 )
            return ivec4( v2Idx.x, v2Idx.y, v2Idx.z - 1, 0 );
        else
            return ivec4( v1Idx.x, v1Idx.y, v1Idx.z - 1, 0 );
    }
    else if( provokingVertexIdx.w == 1 )    // back face, so z == 0
    {
        //               v3 (false)
        //              /|
        //             / |
        //            /  |
        //           /   |
        //          /    |
        //         pv----v1 
        //         |    /
        //         |   /               Z    Y
        //         |  /                 \   |
        //         | /                   \  |
        //         |/                     \ |
        //         v2 (true)        X _____\|   ( Z goes into the screen )
        //
        ivec3 v1Idx = ivec3( pvIdx.x - 1, pvIdx.y,      pvIdx.z );
        ivec3 v2Idx = ivec3( pvIdx.x,     pvIdx.y - 1,  pvIdx.z );
        ivec3 v3Idx = ivec3( pvIdx.x - 1, pvIdx.y + 1,  pvIdx.z );
        if( v2Idx.y < 0 )
            v1v2 =  false;
        else if( v3Idx.y > (volumeDims.y - 1) )
            v1v2 =  true;
        else
            v1v2 = BetweenTwoDirections( fragCoords, pvCds, v1Idx, v2Idx );
        if( v1v2 )
            return ivec4( v2Idx.x - 1, v2Idx.y, v2Idx.z, 1 );
        else
            return ivec4( v1Idx, 1 );
    }
    else if( provokingVertexIdx.w == 2 )    // right face, so x == volumedims.x - 1
    {
        //               v3 (false)
        //              /|
        //             / |
        //            /  |
        //           /   |
        //          /    |             Z
        //         v1----pv            |
        //         |    /              |
        //         |   /               |
        //         |  /                /-------- Y
        //         | /                /
        //         |/                /
        //         v2 (true)        X  ( X comes out of the screen )
        //
        ivec3 v1Idx = ivec3( pvIdx.x, pvIdx.y - 1, pvIdx.z     );
        ivec3 v2Idx = ivec3( pvIdx.x, pvIdx.y - 1, pvIdx.z - 1 );
        ivec3 v3Idx = ivec3( pvIdx.x, pvIdx.y    , pvIdx.z + 1 );
        if( v2Idx.z < 0 )
            v1v2 =  false;
        else if( v3Idx.z > (volumeDims.z - 1) )
            v1v2 =  true;
        else
            v1v2 = BetweenTwoDirections( fragCoords, pvCds, v1Idx, v2Idx );
        if( v1v2 )
            return ivec4( v2Idx.x - 1, v2Idx.y, v2Idx.z, 2 );
        else
            return ivec4( v1Idx.x - 1, v1Idx.y, v1Idx.z, 2 );
    }
    else if( provokingVertexIdx.w == 3 )    // left face, x == 0
    {
        //               v3 (false)
        //              /|
        //             / |
        //            /  |
        //           /   |
        //          /    |
        //         pv----v1 
        //         |    /
        //         |   /               X    Z
        //         |  /                 \   |
        //         | /                   \  |
        //         |/                     \ |
        //         v2 (true)        Y _____\|   ( X goes into the screen )
        //
        ivec3 v1Idx = ivec3( pvIdx.x, pvIdx.y - 1, pvIdx.z     );
        ivec3 v2Idx = ivec3( pvIdx.x, pvIdx.y,     pvIdx.z - 1 );
        ivec3 v3Idx = ivec3( pvIdx.x, pvIdx.y - 1, pvIdx.z + 1 );
        if( v2Idx.z < 0 )
            v1v2 =  false;
        else if( v3Idx.z > (volumeDims.z - 1) )
            v1v2 =  true;
        else
            v1v2 = BetweenTwoDirections( fragCoords, pvCds, v1Idx, v2Idx );
        if( v1v2 )
            return ivec4( v2Idx.x, v2Idx.y - 1, v2Idx.z, 3 );
        else
            return ivec4( v1Idx, 3 );
    }
    else if( provokingVertexIdx.w == 4 )    // top face, y == volumeDims.y - 1
    {
        //               v3 (false)
        //              /|
        //             / |
        //            /  |
        //           /   |
        //          /    |                      Z
        //         pv----v1                     |
        //         |    /                       |
        //         |   /                        |
        //         |  /                X--------\
        //         | /                           \
        //         |/                             \
        //         v2 (true)                       Y  ( Y comes out of the screen )
        //
        ivec3 v1Idx = ivec3( pvIdx.x - 1, pvIdx.y, pvIdx.z     );
        ivec3 v2Idx = ivec3( pvIdx.x,     pvIdx.y, pvIdx.z - 1 );
        ivec3 v3Idx = ivec3( pvIdx.x - 1, pvIdx.y, pvIdx.z + 1 );
        if( v2Idx.z < 0 )
            v1v2 =  false;
        else if( v3Idx.z > volumeDims.z - 1 )
            v1v2 =  true;
        else
            v1v2 = BetweenTwoDirections( fragCoords, pvCds, v1Idx, v2Idx );
        if( v1v2 )
            return ivec4( v2Idx.x - 1, v2Idx.y - 1, v2Idx.z, 4 );
        else
            return ivec4( v1Idx.x, v1Idx.y - 1, v1Idx.z, 4 );
    }
    else    // bottom face, y == 0
    {
        //               v3 (false)
        //              /|
        //             / |
        //            /  |
        //           /   |
        //          /    |
        //         v1----pv 
        //         |    /               Z     Y (Y goes into the screen)
        //         |   /                |    /
        //         |  /                 |   /
        //         | /                  |  /
        //         |/                   | /
        //         v2 (true)            |/_________ X
        //
        ivec3 v1Idx = ivec3( pvIdx.x - 1, pvIdx.y, pvIdx.z     );
        ivec3 v2Idx = ivec3( pvIdx.x - 1, pvIdx.y, pvIdx.z - 1 );
        ivec3 v3Idx = ivec3( pvIdx.x,     pvIdx.y, pvIdx.z + 1 );
        if( v2Idx.z < 0 )
            v1v2 =  false;
        else if( v3Idx.z > volumeDims.z - 1 )
            v1v2 =  true;
        else
            v1v2 = BetweenTwoDirections( fragCoords, pvCds, v1Idx, v2Idx );
        if( v1v2 )
            return ivec4( v2Idx, 5 );
        else
            return ivec4( v1Idx, 5 );
    }
}

//
// Input:  Location to be evaluated in texture coordinates.
// Output: If this location should be skipped.
// Note:   It is skipped in two cases: 1) it represents a missing value
//                                     2) it is outside of clipping planes
//
bool ShouldSkip( const in vec3 tc )
{
    if( hasMissingValue && (texture(missingValueMaskTexture, tc).r != 0u) )
        return true;

    vec4 positionModel  = vec4( (boxMin + tc * (boxMax - boxMin)), 1.0 );
    for( int i = 0; i < 6; i++ )
    {
        if( dot(positionModel, clipPlanes[i]) < 0.0 )
            return true;
    }

    return false;
}

//
// Input:  Location to be evaluated in texture coordinates
// Output: Gradient at that location
//
vec3 CalculateGradient( const in vec3 tc)
{
    vec3 h0 = vec3(-0.5 ) / volumeDimsf;
    vec3 h1 = vec3( 0.5 ) / volumeDimsf;
    vec3 h  = vec3( 1.0 );

    if ((tc.x + h0.x) < 0.0) {
        h0.x = 0.0;
        h.x = 0.5;
    }
    if ((tc.x + h1.x) > 1.0) {
        h1.x = 0.0;
        h.x = 0.5;
    }
    if ((tc.y + h0.y) < 0.0) {
        h0.y = 0.0;
        h.y = 0.5;
    }
    if ((tc.y + h1.y) > 1.0) {
        h1.y = 0.0;
        h.y = 0.5;
    }
    if ((tc.z + h0.z) < 0.0) {
        h0.z = 0.0;
        h.z = 0.5;
    }
    if ((tc.z + h1.z) > 1.0) {
        h1.z = 0.0;
        h.z = 0.5;
    }

    vec3 a0, a1;
    a0.x = texture( volumeTexture, tc + vec3(h0.x,0.0,0.0) ).r;
    a1.x = texture( volumeTexture, tc + vec3(h1.x,0.0,0.0) ).r;
    a0.y = texture( volumeTexture, tc + vec3(0.0,h0.y,0.0) ).r;
    a1.y = texture( volumeTexture, tc + vec3(0.0,h1.y,0.0) ).r;
    a0.z = texture( volumeTexture, tc + vec3(0.0,0.0,h0.z) ).r;
    a1.z = texture( volumeTexture, tc + vec3(0.0,0.0,h1.z) ).r;

    return (a1-a0 / h);
}

// reference implementation: 
// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection
bool RayTriangleIntersect( const in vec3 orig, const in vec3 dir,
                           const in vec3 v0,   const in vec3 v1,  const in vec3 v2,
                           out float t ) 
{
    vec3 v0v1 = v1 - v0;
    vec3 v0v2 = v2 - v0;
    vec3 pvec = cross( dir, v0v2 );
    float det = dot(  v0v1, pvec );

    const float zero = 1e-9;
    if( abs(det) < zero ) // ray and triangle are parallel
        return false;

    float invDet = 1.0 / det;
    vec3  tvec   = orig - v0;
    float u      = dot( tvec, pvec ) * invDet;
    if( u < 0.0 || u > 1.0 )
        return false;

    vec3 qvec    = cross( tvec, v0v1 );
    float v      = dot( dir, qvec ) * invDet;
    if( v < 0.0 || u + v > 1.0 )
        return false;

    t = dot( v0v2, qvec ) * invDet;

    return true;
}

bool  FindNextCell( const in ivec4 step1CellIdx,    const in vec3 startTexture,
                    const in  vec3 rayDirTexture,
                    out      ivec4 step2CellIdx,    out float t )
{
    //          Y
    //        4 __________________5
    //         /|               /|
    //        / |              / |
    //       /  |             /  |
    //     7/___|___________6/   |
    //      |   |           |    |
    //      |   |           |    |
    //      |   |___________|____|  X
    //      |   /0          |   /1
    //      |  /            |  /
    //      | /             | /
    //     3|/______________|/    
    //                     2
    //     Z
    ivec3 V0 = step1CellIdx.xyz;

    ivec3 cubeVertIdx[8]; 
    cubeVertIdx[0] = V0;
    cubeVertIdx[1] = ivec3(V0.x + 1, V0.y    , V0.z     );
    cubeVertIdx[2] = ivec3(V0.x + 1, V0.y    , V0.z + 1 );
    cubeVertIdx[3] = ivec3(V0.x    , V0.y    , V0.z + 1 );
    cubeVertIdx[4] = ivec3(V0.x    , V0.y + 1, V0.z     );
    cubeVertIdx[5] = ivec3(V0.x + 1, V0.y + 1, V0.z     );
    cubeVertIdx[6] = ivec3(V0.x + 1, V0.y + 1, V0.z + 1 );
    cubeVertIdx[7] = ivec3(V0.x    , V0.y + 1, V0.z + 1 );

    vec3 cubeVertCoords[8];
    for( int i = 0; i < 8; i++ )
        cubeVertCoords[i] = GetCoordinates( cubeVertIdx[i] );

    ivec3 triangles[12];
    triangles[0]  =  ivec3( 7, 3, 6 );  // front face
    triangles[1]  =  ivec3( 6, 3, 2 );
    triangles[2]  =  ivec3( 0, 4, 1 );  // back face
    triangles[3]  =  ivec3( 1, 4, 5 );
    triangles[4]  =  ivec3( 5, 1, 6 );  // right face
    triangles[5]  =  ivec3( 6, 1, 2 );
    triangles[6]  =  ivec3( 4, 0, 7 );  // left face
    triangles[7]  =  ivec3( 7, 0, 3 );
    triangles[8]  =  ivec3( 4, 7, 5 );  // top face
    triangles[9]  =  ivec3( 5, 7, 6 );
    triangles[10] =  ivec3( 3, 0, 2 );  // bottom face
    triangles[11] =  ivec3( 2, 0, 1 );

    bool intersect = false;
    for( int i = 0; i < 12; i++ )
        if( i / 2 != step1CellIdx.w )   // not the entry face
        {
            intersect =  RayTriangleIntersect( startTexture, 
                                               rayDirTexture,
                                               cubeVertCoords[ triangles[i][0] ],
                                               cubeVertCoords[ triangles[i][1] ],
                                               cubeVertCoords[ triangles[i][2] ],
                                               t );
            if( intersect )
            {
                if( i / 2 == 0 )    // exits the front face of current cell
                {
                    // enters the back face of the next cell
                    step2CellIdx = ivec4( cubeVertIdx[3], 1 );
                    break;
                }
                else if( i / 2 == 1 )   // exits the back face of current cell
                {
                    // enters the front face of the next cell
                    step2CellIdx = ivec4( V0.x, V0.y, V0.z - 1, 0 );
                    break;
                }
                else if( i / 2 == 2 )   // exits the right face of current cell
                {
                    // enters the left face of the next cell
                    step2CellIdx = ivec4( cubeVertIdx[1], 3 );
                    break;
                }
                else if( i / 2 == 3 )   // exits the left face of current cell
                {
                    // enters the right face of the next cell
                    step2CellIdx = ivec4( V0.x - 1, V0.y, V0.z, 2 );
                    break;
                }
                else if( i / 2 == 4 )   // exits the top face of current cell
                {
                    // enters the bottom face of the next cell
                    step2CellIdx = ivec4(  cubeVertIdx[4], 5 );
                    break;
                }
                else                    // exits the bottom face of current cell
                {
                    // enters the top face of the next cell
                    step2CellIdx = ivec4( V0.x, V0.y - 1, V0.z, 4 );
                    break;
                }
            }
        }

    return intersect;
}

bool CellOutsideBound( const in ivec3 cellIdx )
{
    if( cellIdx.x < 0 || cellIdx.x > volumeDims.x - 2 || 
        cellIdx.y < 0 || cellIdx.y > volumeDims.y - 2 ||
        cellIdx.z < 0 || cellIdx.z > volumeDims.z - 2   )
        return true;
    else
        return false;
}

void main(void)
{
    vec3  lightDirEye   = vec3(0.0, 0.0, 1.0); 

    // Get UV coordinates of this frament
    if( positionClip.w == 0.0 )
        discard;
    vec2 positionUV     = ((positionClip.xy / positionClip.w) + 1.0) / 2.0;

    vec3 stopTexture    = texture( backFaceTexture,  positionUV ).xyz;
    vec3 startTexture   = texture( frontFaceTexture, positionUV ).xyz;
    vec3 rayDirTexture  = stopTexture - startTexture;
    float rayDirLength  = length( rayDirTexture );
    if( rayDirLength < EPSILON )
        discard;

    vec3  step1Texture  = startTexture;
    ivec4 step1CellIdx  = GetCellIndices( step1Texture );

    vec3  step1CellCenterTexture = vec3( step1CellIdx.xyz + 1 ) * volumeStepf;
    float step1Value    = texture( volumeTexture, step1CellCenterTexture ).r;
          color         = texture( colorMapTexture, TranslateValue( step1Value ) );
          color.rgb    *= color.a;

    ivec4 step2CellIdx;
    float t;
    bool intersect = FindNextCell( step1CellIdx, startTexture, rayDirTexture, step2CellIdx, t );

    if( CellOutsideBound( step2CellIdx.xyz ) )
    {
        step2CellIdx = step1CellIdx;
/*
        if( !intersect )
            color = vec4( 1.0, 0.2, 0.2, 1.0 );
        else
        {
            vec3 travTexture = startTexture + t * rayDirTexture;
            float threshold = 1e-4;
            if(  abs( travTexture.x  - stopTexture.x ) > threshold ||
                 abs( travTexture.y  - stopTexture.y ) > threshold ||
                 abs( travTexture.z  - stopTexture.z ) > threshold  )
                color = vec4( 1.0 );
            else
                color = vec4( 0.0 );
        }
*/
    }
    else
    {
        int maxCells     = 16 * int(length( volumeDimsf ));
        int counter;
        for( counter = 0; counter < maxCells; counter++ )
        {
            vec3  step2CellCenterTexture = vec3( step2CellIdx.xyz + 1 ) * volumeStepf;
            float step2Value    = texture( volumeTexture, step2CellCenterTexture ).r;
            vec4  backColor     = texture( colorMapTexture, TranslateValue( step2Value ) );
            color.rgb          += (1.0 - color.a) * backColor.a * backColor.rgb;
            color.a            += (1.0 - color.a) * backColor.a;

            step1CellIdx = step2CellIdx;
            intersect = FindNextCell(  step1CellIdx, startTexture, rayDirTexture, step2CellIdx, t );

            if( CellOutsideBound( step2CellIdx.xyz ) )
            {
                step2CellIdx = step1CellIdx;
                break;
            }
            
/*
            if( !intersect )
            {
                color = vec4( 1.0, 0.2, 0.2, 1.0 );
                break;
            }
            else if( CellOutsideBound( step2CellIdx.xyz ) )
            {
                step2CellIdx = step1CellIdx;

                vec3 travTexture = startTexture + t * rayDirTexture;
                float threshold = 1e-4;
                if(  abs( travTexture.x  - stopTexture.x ) > threshold ||
                     abs( travTexture.y  - stopTexture.y ) > threshold ||
                     abs( travTexture.z  - stopTexture.z ) > threshold  )
                    color = vec4( 1.0 );
                else
                    color = vec4( 0.0 );

                break;
            }
*/
        }

        if( !intersect )
            color = vec4( 1.0, 0.2, 0.2, 1.0 );

    }

/*
    vec3 travTexture = startTexture + t * rayDirTexture;
    const float threshold = 1e-4;
    if(  abs( travTexture.x  - stopTexture.x ) > threshold ||
         abs( travTexture.y  - stopTexture.y ) > threshold ||
         abs( travTexture.z  - stopTexture.z ) > threshold  )
        color = vec4( 1.0 );
    else
        color = vec4( 0.0 );
*/
        





    /* if( color.r < EPSILON && color.g < EPSILON && color.b < EPSILON )
        color.a = 1.0;
    else if( color.r > 1.0 - EPSILON && color.g > 1.0 - EPSILON && color.b > 1.0 - EPSILON )
        color.a = 1.0; */

#if 0
    float nStepsf       = rayDirLength  / stepSize1D;
    vec3  stepSize3D    = rayDirTexture / nStepsf;

    vec3  step1Texture  = startTexture;
    if( ShouldSkip( step1Texture ) )
    {
        color = vec4( 0.0f );
    }
    else
    {
        float step1Value = texture( volumeTexture, step1Texture ).r;
              color      = texture( colorMapTexture, TranslateValue(step1Value) );
              color.rgb *= color.a;
    }

    // let's do a ray casting! 
    for( int i = 0; i < int(nStepsf); i++ )
    {
        if( color.a > 0.999f )  // You can still see through with 0.99...
            break;

        vec3 step2Texture = startTexture + stepSize3D * float(i + 1);
        if( ShouldSkip( step2Texture ) )
            continue;

        float step2Value  = texture( volumeTexture, step2Texture ).r;
        vec4  backColor   = texture( colorMapTexture, TranslateValue(step2Value) );
        
        // Apply lighting if big enough gradient
        if( lighting )
        {
            vec3 gradientModel = CalculateGradient( step2Texture );
            if( length( gradientModel ) > EPSILON )
            {
                vec3 gradientEye = (transposedInverseMV * vec4( gradientModel, 0.0f )).xyz;
                     gradientEye = normalize( gradientEye );
                float diffuse    = abs( dot(lightDirEye, gradientEye) );

                // Calculate eye space coordinates of "step2Texture"
                vec3 step2Model  = boxMin + step2Texture * (boxMax - boxMin);
                vec3 step2Eye    = (ModelView * vec4(step2Model, 1.0f)).xyz;
                vec3 viewDirEye  = normalize( -step2Eye );

                vec3 reflectionEye = reflect( -lightDirEye, gradientEye );
                float specular   = pow( max(0.0f, dot( reflectionEye, viewDirEye )), specularExp ); 
                backColor.rgb    = backColor.rgb * (ambientCoeff + diffuse * diffuseCoeff) + 
                                   specular * specularCoeff;
            }
        }   // End lighting

        // Color compositing
        color.rgb += (1.0f - color.a) * backColor.a * backColor.rgb;
        color.a   += (1.0f - color.a) * backColor.a;
    }   // End ray casting
#endif

}       // End main()

