#version 410 core

in vec4 positionClip;   // vertex position in the clip space
in vec4 positionEye;    // vertex position in the eye space

uniform sampler2D backFaceTexture;
uniform sampler2D frontFaceTexture;
uniform sampler3D volumeTexture;
uniform sampler3D missingValueMaskTexture;
uniform sampler1D colorMapTexture;

uniform vec2 valueRange;        // min and max values of the variable
uniform vec2 colorMapRange;     // min and max values on the color map
uniform vec3 volumeDimensions;  // Number of vertices of the volumeTexture

layout(location = 0) out vec4 color;

//
// Input:  normalized value w.r.t. valueRange.
// Output: normalized value w.r.t. colorMapRange.
//
float TranslateValue( in float value )
{
    float orig = value * (valueRange.y - valueRange.x) + valueRange.x;
    return (orig - colorMapRange.x) / (colorMapRange.y - colorMapRange.x);
}

//
// Input:  Location to be evaluated in texture coordinates
// Output: Gradient at that location
//
vec3 CalculateGradient(in vec3 tc)
{
    vec3 h0 = vec3(-0.5 ) / volumeDimensions;
    vec3 h1 = vec3( 0.5 ) / volumeDimensions;
    vec3 h  = vec3( 1.0 );

    if ((tc.x + h0.x) < 0.0) {
        h0.x = 0.0;
        h.x = 0.5;
    }
    if ((tc.x + h1.x) > 1.0) {
        h1.x = 0.0;
        h.x = 0.5;
    }
    if ((tc.y + h0.y) < 0.0) {
        h0.y = 0.0;
        h.y = 0.5;
    }
    if ((tc.y + h1.y) > 1.0) {
        h1.y = 0.0;
        h.y = 0.5;
    }
    if ((tc.z + h0.z) < 0.0) {
        h0.z = 0.0;
        h.z = 0.5;
    }
    if ((tc.z + h1.z) > 1.0) {
        h1.z = 0.0;
        h.z = 0.5;
    }

    vec3 a0, a1;
    a0.x = texture(volumeTexture, tc + vec3(h0.x,0.0,0.0)).x;
    a1.x = texture(volumeTexture, tc + vec3(h1.x,0.0,0.0)).x;
    a0.y = texture(volumeTexture, tc + vec3(0.0,h0.y,0.0)).x;
    a1.y = texture(volumeTexture, tc + vec3(0.0,h1.y,0.0)).x;
    a0.z = texture(volumeTexture, tc + vec3(0.0,0.0,h0.z)).x;
    a1.z = texture(volumeTexture, tc + vec3(0.0,0.0,h1.z)).x;

    return (a1-a0 / h);
}


void main(void)
{
    int nSteps = 1000;

    // Get UV coordinates of this frament
    if( positionClip.w == 0.0f )
        discard;
    vec2 positionUV = ((positionClip.xy / positionClip.w) + 1.0f) / 2.0f;

    vec4 stopTexture    = vec4(texture( backFaceTexture,  positionUV ).xyz, 1.0f);
    vec4 startTexture   = vec4(texture( frontFaceTexture, positionUV ).xyz, 1.0f);
    vec4 rayDirTexture  = stopTexture - startTexture;
    if( length( rayDirTexture ) == 0.0f )
        discard;

    //color   = vec4( length(rayDirTexture)/1.732f );
    //color.a = clamp( color.a * 2.0f, 0.0f, 1.0f );

    vec4  stepSize      = rayDirTexture / float(nSteps);
    vec4  step1Texture  = startTexture;
    if( texture(missingValueMaskTexture, step1Texture.xyz).x > 0 )    // missing value
        color           = vec4( 0.0f );
    else
    {
        float step1Value = texture( volumeTexture, step1Texture.xyz ).w;
              color      = texture( colorMapTexture, TranslateValue(step1Value) );
    }

    // let's do a ray casting! 
    for( int i = 0; i < nSteps; i++ )
    {
        vec4 step2Texture = startTexture + stepSize * float(i + 1);
        if( texture(missingValueMaskTexture, step2Texture.xyz).x > 0 )    // missing value
            continue;
        else
        {
            float step2Value  = texture( volumeTexture, step2Texture.xyz ).w;
            vec4  backColor   = texture( colorMapTexture, TranslateValue(step2Value) );
            color.rgb        += (1.0f - color.a) * backColor.a * backColor.rgb;
            color.a          += (1.0f - color.a) * backColor.a;
        }

        if( color.a > 0.99 )
            break;

        step1Texture      = step2Texture;
    }
}

