/*****************************************************************************
*
* Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtWASPFileFormat.C                           //
// ************************************************************************* //

#include <avtWASPFileFormat.h>
#include <avtIntervalTree.h>

#include <string>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>
#include <DebugStream.h>

#include <string>
#include <sstream>
#include <stdlib.h>

bool useBlocks=1;

template <typename T>
string ToString(T val)
{
    stringstream stream;
    stream << val;
    return stream.str();
}

std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems) {
    std::stringstream ss(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}

// ****************************************************************************
//  Method: avtWASPFileFormat constructor
//
//  Programmer: pearse -- generated by xml2avt
//  Creation:   Wed Jan 20 15:04:04 PST 2016
//
// ****************************************************************************

avtWASPFileFormat::avtWASPFileFormat(const char *filename)
: avtMTMDFileFormat(filename){
	initialized = false;
	inFile = filename;
	wasp = new VAPoR::WASP(1);
}

avtWASPFileFormat::~avtWASPFileFormat(){
	if (wasp) delete wasp;
}
	
void avtWASPFileFormat::ActivateTimestep() {
	Initialize();
}
	
void avtWASPFileFormat::Initialize() {
	size_t nlevels, maxcratio;
	vector<size_t> dims,bs;

	if(!initialized){
		bool okay = false;
		std::vector <std::string> allVars;
		
		wasp->Open(inFile,0);
		wasp->InqVarnames(allVars);
		std::vector<std::string>::iterator it;
		for (it=allVars.begin(); it != allVars.end(); ++it){
			wasp->InqVarWASP(*it,okay);
			if (okay){
				wasp->InqVarDimlens(*it,0,dims,bs);
				if (dims.size() > 2) {
					varNames.push_back(*it);
					debug1 << "WASP says " << *it << " is ok!" << endl;
				}
				else {
					debug1 << "Ommitting 2D variable " << *it << endl;
				}
			}
			else	
				debug1 << "WASP says " << *it << " is NOT ok!" << endl;
		}

		initialized = true;
	}
	else {
		debug1 << "We've already initialized" << endl;
	}
}

// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: pearse -- generated by xml2avt
//  Creation:   Wed Jan 20 15:04:04 PST 2016
//
// ****************************************************************************

int
avtWASPFileFormat::GetNTimesteps(void)
{
	// We are only supporting one timestep at a time
	return 1;
}


// ****************************************************************************
//  Method: avtWASPFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: pearse -- generated by xml2avt
//  Creation:   Wed Jan 20 15:04:04 PST 2016
//
// ****************************************************************************

void
avtWASPFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtWASPFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: pearse -- generated by xml2avt
//  Creation:   Wed Jan 20 15:04:04 PST 2016
//
// ****************************************************************************

void
avtWASPFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
	Initialize(); 


	string wname;
	int refLevels;
	string varName;
	vector <size_t> dims, bs;
	std::vector<std::string>::iterator it;
	int blockedDims[3];

	// Iterate over each variable
	for (it=varNames.begin(); it != varNames.end(); ++it){

		varName = *it;
		int rc = wasp->OpenVarRead(varName,0,3);
		if (rc!=0) {
			debug1 << "Unable to open variable " << varName << endl;
			debug1 << "rc: " << rc << endl;
		}

		// Iterate over each refinement level and lod
		refLevels = wasp->InqVarNumRefLevels(varName);
		for (int i=0; i<refLevels; i++){
	
			// Calculate the dimensions of our set of blocks at current ref. level
			int rc = wasp->InqVarDimlens(varName,i,dims,bs);
			if (bs.empty()){
				bs = dims;
			}

			// Swap Z and X dimension axes			
			int tmp = bs[0];
			bs[0] = bs[2];
			bs[2] = tmp;
			tmp = dims[0];
			dims[0] = dims[2];
			dims[2] = tmp;

			if (rc) EXCEPTION1(InvalidDBTypeException,"The WASP file's dimensionality could not be read.");

			// Calculate number of blocks on each axis
			for (int j=0; j<3; j++){
				blockedDims[j] = dims[j]/bs[j];
				if (dims[j]%bs[j] > 0) blockedDims[j]+=1;	
			}

			// Aggregate remaining metadata
			avtMeshType meshType = AVT_RECTILINEAR_MESH;
			int numBlocks = 1;
			if (useBlocks) numBlocks = blockedDims[0] * blockedDims[1] * blockedDims[2];

			int blockOrigin = 0;
			int spatialDimension = dims.size();
			int topologicalDimension = 3;
			double *extents = NULL;
	
			string meshName = varName + "-mesh-" + ToString(i);
			AddMeshToMetaData(md, meshName, meshType, extents, numBlocks, blockOrigin,
							spatialDimension, topologicalDimension);

			vector<size_t> cratios;
			wasp->InqVarCompressionParams(*it,wname,bs,cratios);

			string visitVarName;
			for (size_t j=0; j<cratios.size(); j++){
				visitVarName = varName + "/ref" + ToString(i) + "/lod" + ToString(cratios[j]);
				AddScalarVarToMetaData(md, visitVarName, meshName, AVT_ZONECENT);
			}
		}
	}
}


// ****************************************************************************
//  Method: avtWASPFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: pearse -- generated by xml2avt
//  Creation:   Wed Jan 20 15:04:04 PST 2016
//
// ****************************************************************************

vtkDataSet *
avtWASPFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
	// Split up meshname to get level and variable information
	string meshName2 = meshname;
	vector<string> components;
	split(meshName2, '-', components);
	string varName = components[0];
	int level = atoi(components[2].c_str());
	
	int rc = wasp->OpenVarRead(varName,level,1);
	if (rc!=0) {
		debug1 << "Unable to open variable " << varName << endl;
		debug1 << "rc: " << rc << endl;
	}

	vector <size_t> dims, bs;
	wasp->InqVarDimlens(varName,level,dims,bs);
	if (bs.empty()){
		bs = dims;
	}
	
	// Swap Z and X dimension axes			
	int tmp = bs[0];
	bs[0] = bs[2];
	bs[2] = tmp;
	tmp = dims[0];
	dims[0] = dims[2];
	dims[2] = tmp;

	vtkFloatArray *coords[3] = {0,0,0};
	int blockedDims[3], meshDims[3];

	if (useBlocks) {
		for (int i=0; i<3; i++) meshDims[i] = bs[i]+1;
	}
	else {
		for (int i=0; i<3; i++) meshDims[i] = dims[i]+1;
	}

	int xStart=0, yStart=0, zStart=0;
	int xEnd=dims[0]+1;
	int yEnd=dims[1]+1;
	int zEnd=dims[2]+1;

	if (useBlocks){
		for (int j=0; j<3; j++){
			blockedDims[j] = dims[j]/bs[j];
			if (dims[j]%bs[j] > 0) blockedDims[j] = blockedDims[j]+1;	
		}
		
		int xBlock = domain % blockedDims[0];
		int yBlock = (domain%(blockedDims[0]*blockedDims[1]))/blockedDims[0];
		int zBlock = domain/(blockedDims[0]*blockedDims[1]);
	
		xStart = bs[0]*xBlock;
		yStart = bs[1]*yBlock;
		zStart = bs[2]*zBlock;
		xEnd = bs[0]*(xBlock+1);
		yEnd = bs[1]*(yBlock+1);
		zEnd = bs[2]*(zBlock+1);

		// If we are looking at the last block on either the x, y, or z axis,
		// we may need to trim the end point if the domain is not a multiple
		// of our block size (in other words, or blocks overshoot our domain)
		if ((xBlock == blockedDims[0]-1)&&(dims[0]%bs[0]!=0)){
			xEnd -= bs[0] - dims[0]%bs[0];
			meshDims[0] -= bs[0] - dims[0]%bs[0];
		}
		if ((yBlock == blockedDims[1]-1)&&(dims[1]%bs[1]!=0)){
			yEnd -= bs[1] - dims[1]%bs[1];
			meshDims[1] -= bs[1] - dims[1]%bs[1];
		}
		if ((zBlock == blockedDims[2]-1)&&(dims[2]%bs[2]!=0)){
			zEnd -= bs[2] - dims[2]%bs[2];
			meshDims[2] -= bs[2] - dims[2]%bs[2];
		}
	}

	int xCount = xEnd-xStart+1;
	int yCount = yEnd-yStart+1;
	int zCount = zEnd-zStart+1;

	// Read the X coordinates from the file.
	coords[0] = vtkFloatArray::New();
	coords[0]->SetNumberOfTuples(xCount);
	float *xarray = (float *)coords[0]->GetVoidPointer(0);
	for (int i=0; i<xCount; i++){
		xarray[i] = (float)(xStart+i)/dims[0];
	}

	// Read the Y coordinates from the file.
	coords[1] = vtkFloatArray::New();
	coords[1]->SetNumberOfTuples(yCount);
	float *yarray = (float *)coords[1]->GetVoidPointer(0);
	for (int i=0; i<yCount; i++){
		yarray[i] = (float)(yStart+i)/dims[1];
	}

	// Read the Z coordinates from the file.
	coords[2] = vtkFloatArray::New();
	if(dims.size() > 2)
	{
		coords[2]->SetNumberOfTuples(zCount);
		float *zarray = (float *)coords[2]->GetVoidPointer(0);
		for (int i=0; i<zCount; i++){
			zarray[i] = (float)(zStart+i)/dims[2];
		}
	}
	else
	{
		coords[2]->SetNumberOfTuples(1);
		coords[2]->SetComponent(0, 0, 0.);
	}	

	// Create the vtkRectilinearGrid object and set its dimensions
	// and coordinates.
	vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New();
	rgrid->SetDimensions(meshDims);
	rgrid->SetXCoordinates(coords[0]);
	coords[0]->Delete();
	rgrid->SetYCoordinates(coords[1]);
	coords[1]->Delete();
	rgrid->SetZCoordinates(coords[2]);
	coords[2]->Delete();
	return rgrid;
}


// ****************************************************************************
//  Method: avtWASPFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: pearse -- generated by xml2avt
//  Creation:   Wed Jan 20 15:04:04 PST 2016
//
// ****************************************************************************

vtkDataArray *
avtWASPFileFormat::GetVar(int timestate, int domain, const char *varname)
{
	// Split varname to get level and lod info
	string inName = varname;
	vector<string> components;
	split(inName, '/', components);
	string varName = components[0];
	string tmpLevel = components[1].erase(0,3);
	string tmpLod = components[2].erase(0,3);
	int level = atoi(tmpLevel.c_str());
	int lod = atoi(tmpLod.c_str());
	size_t blockedDims[3];	

	// Find the index of our compression ratio	
	std::string temp;
	vector<size_t> cratios, temp2;
	wasp->InqVarCompressionParams(varName,temp,temp2,cratios);
	for (int i=0; i<cratios.size(); i++){
		if (lod == cratios[i]) lod = i;
	}

	int rc = wasp->OpenVarRead(varName,level,lod);
	if (rc!=0) {
		debug1 << "Unable to open variable " << varName << endl;
		debug1 << "rc: " << rc << endl;
	}

	vector <size_t> dims, vaporDims, bs, start, count;
	rc = wasp->InqVarDimlens(varName,level,vaporDims,bs);
	if (bs.empty()){
		bs = dims;
	}

	int tmp = bs[0];
	bs[0] = bs[2];
	bs[2] = tmp;
	dims.push_back(vaporDims[2]);
	dims.push_back(vaporDims[1]);
	dims.push_back(vaporDims[0]);


	if (rc!=0) {
		debug1 << "Unable to inquire variable " << varName << endl;
		debug1 << "rc: " << rc << endl;
	}

	float* data;
	int xBlock, yBlock, zBlock;
	int numVaporDataPoints = 1;
	int numVisitDataPoints = 1;
	count = bs;			// Number of elements in current block
	if (useBlocks) {
	
		// blockedDims is xyz indexed	
		for (int j=0; j<3; j++){
			blockedDims[j] = dims[j]/bs[j];
			if (dims[j]%bs[j] > 0) blockedDims[j] = blockedDims[j]+1;	
		}

		int xySize = blockedDims[0] * blockedDims[1];
		xBlock = domain % blockedDims[0];
		yBlock = (domain % xySize) / blockedDims[0];
		zBlock = domain / xySize;

		start.push_back(bs[2]*zBlock);
		start.push_back(bs[1]*yBlock);
		start.push_back(bs[0]*xBlock);

		// If we are looking at the last block on either the x, y, or z axis,
		// we may need to trim the end point if the domain is not a multiple
		// of our block size (in other words, or blocks overshoot our domain)
		if ((xBlock == blockedDims[0]-1)&&(dims[0]%bs[0]!=0)){
			count[0] -= count[0]-dims[0]%count[0];
		}
		if ((yBlock == blockedDims[1]-1)&&(dims[1]%bs[1]!=0)){
			count[1] -= count[1]-dims[1]%count[1];
		}
		if ((zBlock == blockedDims[2]-1)&&(dims[2]%bs[2]!=0)){
			count[2] -= count[2]-dims[2]%count[2];
		}
		
		for (int i=0; i<bs.size(); i++)	{
			numVaporDataPoints *= bs[i];
			numVisitDataPoints *= count[i];
		}

	}
	else {
		count = dims;
		start.push_back(0);
		start.push_back(0);
		start.push_back(0);
		for (int i=0; i<dims.size(); i++) numVaporDataPoints *= dims[i];
		numVisitDataPoints = numVaporDataPoints;
	}

	data = new float[numVaporDataPoints];

	vector<size_t> vaporCount;
	vaporCount.push_back(count[2]);
	vaporCount.push_back(count[1]);
	vaporCount.push_back(count[0]);

	if (useBlocks) rc = wasp->GetVara(start,vaporCount,data);
	else rc = wasp->GetVara(start,vaporDims,data);

	// Populate visit data array
	vtkFloatArray *rv = vtkFloatArray::New();
	rv->SetNumberOfTuples(numVisitDataPoints);
	int visitIndex, vaporIndex, x, y, z;
	for (int i = 0 ; i < numVisitDataPoints ; i++){
		rv->SetTuple1(i,data[i]);
	}
	
	if (data) delete [] data;
	return rv;
}

void* avtWASPFileFormat::GetAuxiliaryData(const char *var, int timestep,
                                    int domain, const char *type, void *,
                                    DestructorFunction &df) {
	void *retval = 0;

	if(strcmp(type, AUXILIARY_DATA_SPATIAL_EXTENTS) == 0) {
		vector<size_t> dims,bs;
		string inName = var;
		vector<string> components;
		split(inName, '-', components);
		string varName = components[0];
		int level = atoi(components[2].c_str());
		wasp->InqVarDimlens(varName,level,dims,bs);
		if (bs.empty() || !useBlocks){
			bs = dims;
		}
		int tmp = bs[0];
		bs[0] = bs[2];
		bs[2] = tmp;
		tmp = dims[0];
		dims[0] = dims[2];
		dims[2] = tmp;

		int ndoms = 1;
		vector<size_t> blockedDims;
		blockedDims.push_back(1);
		blockedDims.push_back(1);
		blockedDims.push_back(1);
		if (useBlocks){
			for (int j=0; j<3; j++){
				blockedDims[j]= dims[j]/bs[j];
				if (dims[j]%bs[j] > 0) blockedDims[j] +=1;	
			}
			ndoms = blockedDims[0] * blockedDims[1] * blockedDims[2];
		}


		// Read the spatial extents for each domain of the
		// mesh. This information should be in a single
		// and should be available without having to
		// read the real data. The expected format for
		// the data in the spatialextents array is to
		// repeat the following pattern for each domain:
		// xmin, xmax, ymin, ymax, zmin, zmax.
		double *spatialextents = new double[ndoms * 6];
		int xMin, xMax, yMin, yMax, zMin, zMax;

		// Create an interval tree
		avtIntervalTree *itree = new avtIntervalTree(ndoms, 3);
		double extents[6];
		for(int dom = 0; dom < ndoms; dom++)
		{

			int xBlock, yBlock, zBlock;
			xBlock = dom % blockedDims[0];
			yBlock = (dom % (blockedDims[0]*blockedDims[1])) / blockedDims[0];
			zBlock = dom / (blockedDims[0]*blockedDims[1]);
			xMin = xBlock*bs[0];
			yMin = yBlock*bs[1];
			zMin = zBlock*bs[2];
			xMax = (xBlock+1)*bs[0];
			yMax = (yBlock+1)*bs[1];
			zMax = (zBlock+1)*bs[2];

			// If we are looking at the last block on either the x, y, or z axis,
			// we may need to trim the end point if the domain is not a multiple
			// of our block size (in other words, or blocks overshoot our domain)
			if ((xBlock == blockedDims[0]-1) && (dims[0]%bs[0]!=0))
				xMax -= bs[0] - dims[0]%bs[0];
			if ((yBlock == blockedDims[1]-1) && (dims[1]%bs[1]!=0))
				yMax -= bs[1] - dims[1]%bs[1];
			if ((zBlock == blockedDims[2]-1) && (dims[2]%bs[2]!=0))
				zMax -= bs[2] - dims[2]%bs[2];

			extents[0] = xMin/(float)dims[0];
			extents[1] = xMax/(float)dims[0];
			extents[2] = yMin/(float)dims[1];
			extents[3] = yMax/(float)dims[1];
			extents[4] = zMin/(float)dims[2];
			extents[5] = zMax/(float)dims[2];

			itree->AddElement(dom, extents);
		}
		itree->Calculate(true);
		
		// Delete temporary array.
		if (spatialextents) delete [] spatialextents;
		
		// Set return values
		retval = (void *)itree;
		df = avtIntervalTree::Destruct;
	}
	return retval;
}
